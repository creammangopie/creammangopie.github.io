<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>springBoot(一)：创建springBoot项目</title>
    <url>/2019/12/30/springBoot1/</url>
    <content><![CDATA[<h2 id="springBoot是什么"><a href="#springBoot是什么" class="headerlink" title="springBoot是什么"></a>springBoot是什么</h2><p>Spring Boot是构建所有基于Spring的应用程序的起点。Spring Boot旨在通过最少的Spring前期配置使您尽快启动并运行。</p>
<p>Spring Boot使创建可运行的独立，生产级基于Spring的应用程序变得容易。我们对Spring平台和第三方库持固执己见的观点，这样您就可以以最小的麻烦开始使用。大多数Spring Boot应用程序只需要很少的Spring配置。</p>
<a id="more"></a>

<p>您可以使用Spring Boot创建可以通过使用java -jar或更传统的战争部署启动的Java应用程序。我们还提供了一个运行“ spring脚本”的命令行工具。</p>
<p>我们的主要目标是：</p>
<p>为所有Spring开发提供根本上更快且可广泛访问的入门体验。</p>
<p>开箱即用，但由于需求开始与默认值有所出入，因此很快就会摆脱困境。</p>
<p>提供一系列大型项目通用的非功能性功能（例如嵌入式服务器，安全性，指标，运行状况检查和外部化配置）。</p>
<p>完全没有代码生成，也不需要XML配置。<br>(来自于spring官方文档)</p>
<h2 id="从spring官网构建一个项目"><a href="#从spring官网构建一个项目" class="headerlink" title="从spring官网构建一个项目"></a>从spring官网构建一个项目</h2><p><strong>Maven构建项目</strong></p>
<ul>
<li>1、访问<a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a></li>
<li>2、选择构建工具 Maven Project、Java、Spring Boot 版本 2.2.3 ：<br><img src="/2019/12/30/springBoot1/1.png" alt></li>
<li>3、点击 Generate Project 下载项目压缩包</li>
<li>4、解压后，使用 Idea 导入项目，import -&gt; 选择解压后的文件夹 -&gt; OK，选择 Maven 一路 Next，OK done!</li>
</ul>
<p><strong>Idea 构建项目</strong></p>
<ul>
<li>1、选择 File -&gt; New —&gt; Project… </li>
<li>2、选择 Spring Initializr，Next 也会出现上述类似的配置界面，Idea 帮我们做了集成</li>
<li>3、填写相关内容后，点击 Next 选择依赖的包再点击 Next，最后确定信息无误点击 Finish。</li>
</ul>
<p>创建完成后就是以下这样子了：<br><img src="/2019/12/30/springBoot1/2.png" alt></p>
<ul>
<li>src/main/java 程序开发以及主程序入口</li>
<li>src/main/resources 配置文件</li>
<li>src/test/java 测试代码</li>
</ul>
<p><strong>引入web</strong></p>
<p>1、pom.xml中添加支持web的模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>pom.xml 文件中默认有两个模块：</p>
<ul>
<li>spring-boot-starter ：核心模块，包括自动配置支持、日志和 YAML，如果引入了 spring-boot-starter-web web 模块可以去掉此配置，因为 spring-boot-starter-web 自动依赖了 spring-boot-starter。</li>
<li>spring-boot-starter-test ：测试模块，包括 JUnit、Hamcrest、Mockito。</li>
</ul>
<p>2、写一个controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HellowWorldController &#123;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String index()&#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加了@RestController就不需要再写@ResponseBody了。</p>
<p>3、启动主程序，打开浏览器访问 <a href="http://localhost:8080/hello，就可以看到效果了。" target="_blank" rel="noopener">http://localhost:8080/hello，就可以看到效果了。</a></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>打开的src/test/下的测试入口，编写简单的 http 请求来测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">public class HelloTests &#123;</span><br><span class="line"></span><br><span class="line">    private MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    @BeforeEach</span><br><span class="line">    public void setUp()&#123;</span><br><span class="line">        mvc &#x3D; MockMvcBuilders.standaloneSetup(new HellowWorldController()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getHello() throws Exception&#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;hello&quot;).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(equalTo(&quot;Hello World&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在springBoot2.2.3中@SpringBootTest注解集成了@ExtendWith({SpringExtension.class})，<br><img src="/2019/12/30/springBoot1/3.png" alt></p>
<p>在Junit4中要加@RunWith(SpringRunner.class)。</p>
<ul>
<li>status()，content()，equalTo在代码中没有找到引用，手动引入的：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line">import static org.hamcrest.Matchers.equalTo;</span><br></pre></td></tr></table></figure>
运行test结果如下：<br><img src="/2019/12/30/springBoot1/4.png" alt></li>
</ul>
<h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>Junit5升级之后很多注解发生变化。</p>
<table>
<thead>
<tr>
<th align="center">JUnit4</th>
<th align="center">JUnit5</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@Test</td>
<td align="center">@Test</td>
<td align="left">表示该方法是一个测试方法。JUnit5与JUnit 4的@Test注解不同的是，它没有声明任何属性，因为JUnit Jupiter中的测试扩展是基于它们自己的专用注解来完成的。这样的方法会被继承，除非它们被覆盖</td>
</tr>
<tr>
<td align="center">@BeforeClass</td>
<td align="center">@BeforeAll</td>
<td align="left">表示使用了该注解的方法应该在当前类中所有使用了@Test @RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行；</td>
</tr>
<tr>
<td align="center">@AfterClass</td>
<td align="center">@AfterAll</td>
<td align="left">表示使用了该注解的方法应该在当前类中所有使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后执行；</td>
</tr>
<tr>
<td align="center">@Before</td>
<td align="center">@BeforeEach</td>
<td align="left">表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行</td>
</tr>
<tr>
<td align="center">@After</td>
<td align="center">@AfterEach</td>
<td align="left">表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后 执行</td>
</tr>
<tr>
<td align="center">@Ignore</td>
<td align="center">@Disabled</td>
<td align="left">用于禁用一个测试类或测试方法</td>
</tr>
<tr>
<td align="center">@Category</td>
<td align="center">@Tag</td>
<td align="left">用于声明过滤测试的tags，该注解可以用在方法或类上；类似于TesgNG的测试组或JUnit 4的分类。</td>
</tr>
<tr>
<td align="center">@Parameters</td>
<td align="center">@ParameterizedTest</td>
<td align="left">表示该方法是一个参数化测试</td>
</tr>
<tr>
<td align="center">@RunWith</td>
<td align="center">@ExtendWith</td>
<td align="left">@Runwith就是放在测试类名之前，用来确定这个类怎么运行的</td>
</tr>
<tr>
<td align="center">@Rule</td>
<td align="center">@ExtendWith</td>
<td align="left">Rule是一组实现了TestRule接口的共享类，提供了验证、监视TestCase和外部资源管理等能力</td>
</tr>
<tr>
<td align="center">@ClassRule</td>
<td align="center">@ExtendWith</td>
<td align="left">@ClassRule用于测试类中的静态变量，必须是TestRule接口的实例，且访问修饰符必须为public。</td>
</tr>
</tbody></table>
<h2 id="添加项目热启动"><a href="#添加项目热启动" class="headerlink" title="添加项目热启动"></a>添加项目热启动</h2><p>1、pom.xml添加以下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;fork&gt;true&lt;&#x2F;fork&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>
<p>2、yml配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devtools:</span><br><span class="line">  livereload:</span><br><span class="line">    enabled: true #是否支持livereload</span><br><span class="line">    port: 35729</span><br><span class="line">  restart:</span><br><span class="line">    enabled: true #是否支持热部署</span><br></pre></td></tr></table></figure>
<p>3、开启idea自动make功能<br>settings:<br><img src="/2019/12/30/springBoot1/5.png" alt></p>
<p>4、ctrl + shift + alt + /,选择Registry,勾上 Compiler autoMake allow when app running<br><img src="/2019/12/30/springBoot1/6.png" alt></p>
<p>5、安装livereload插件</p>
<p>livereload 通过引入的脚本livereload.js在 livereload 服务和浏览器之间建立了一个 WebSocket 连接。每当监测到文件的变动，livereload 服务就会向浏览器发送一个信号，浏览器收到信号后就刷新页面，实现了实时刷新的效果。每次启动时，需要点击对应的图标。<br>下载livereload插件，将其安装到chrome扩展程序中。<br><img src="/2019/12/30/springBoot1/7.png" alt></p>
<p>6、测试</p>
<ul>
<li>修改类 应用会重启</li>
<li>修改配置文件 应用会重启</li>
<li>修改静态文件（html、css等），应用不会重启，但是会调用livereload，浏览器会自动刷新，显示最新的修改内容。</li>
</ul>
]]></content>
      <categories>
        <category>springBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>热部署</tag>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的事务管理</title>
    <url>/2019/12/27/Mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h1><p>事务是逻辑上的一组操作，要求这一组操作要么同时完成 要么同时不完成。</p>
<h1 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h1><p>数据库默认就有事务，mysql中默认情况下一条语句独占一个事务。<br>也可以通过手动控制事务：</p>
<a id="more"></a>
<h2 id="sql控制事务："><a href="#sql控制事务：" class="headerlink" title="sql控制事务："></a>sql控制事务：</h2><p>start transaction; #开启一个事务 这条语句之后的所有的sql都将处在同一个事务中。这些sql都不会立即起作用 - 没有改变底层真正的数据。</p>
<p>commit; #提交事务 这个事务中所有的sql对数据库的影响立即发生 - 真正改变底层数据。</p>
<p>rollback; #回滚事务 撤销这个事务中所有的操作可能的对数据库的影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update account <span class="keyword">set</span> money = money-100 where name='a';</span><br><span class="line">update account <span class="keyword">set</span> money = money+100 where name='b';</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">start transaction;</span><br><span class="line">update account <span class="keyword">set</span> money = money-100 where name='a';</span><br><span class="line">update account <span class="keyword">set</span> money = money+100 where name='b';</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>
<h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">conn.setAutoCommit(false);#开启了事务，接下来在这个连接执行的所有sql都将处在同一个事务当中。</span><br><span class="line">			....</span><br><span class="line">conn.commit();#提交事务，将这个连接上执行的事务提交，对数据库产生影响。</span><br><span class="line">conn.rollback();#回滚事务，取消这个连接上执行的事务。</span><br><span class="line"></span><br><span class="line">SavePoint sp = conn.setSavePoint();</span><br><span class="line">conn.rollback(sp);</span><br></pre></td></tr></table></figure>
<p>要注意，回滚到回滚点时，回滚点之前的代码仍然是未提交也未回滚的状态，如果希望对数据库产生影响仍然需要进行提交的操作。</p>
<h1 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性  - ACID"></a>事务的四大特性  - ACID</h1><p>原子性 - 事务中的一组操作是不可分割的一个整体，要么一起成功，要么一起失败。</p>
<p>一致性 - 事务前后 无论事务是否成功 数据库应该都保持一个完整性的状态。数据库中数据是业务完整且约束完整的。</p>
<p>隔离性 - 多个并发事务之间应该互相隔离 互不影响</p>
<p>持久性 - 一个事务成功对数据库产生的影响是永久性的，无论发生什么情况 这种影响都不会被取消。</p>
<h1 id="隔离性的问题"><a href="#隔离性的问题" class="headerlink" title="隔离性的问题"></a>隔离性的问题</h1><p>加锁：同一时间内只能有一个人操作数据，可以完美的保证隔离性，但是这样一来数据库就相当于工作在单线程的状态下，同一时间只能有一个事务操作，并发的效率非常低下。</p>
<p>而现实生活中并不是所有的场景下都需要那么严格的事务隔离，在不同的业务场景下对隔离性的要求是不同的。</p>
<p>所以数据库的设计者在设计隔离性时并没有将隔离性写死，而是提供了不同的选项，数据库的使用者可以在使用数据时根据自身需求选择对应的选项来得到相应的隔离能力和性能。</p>
<p>通过这些选项，数据库使用者可以在数据库的隔离能力和性能间做一个权衡，从而在保证需要的隔离性的基础上得到尽量好的性能。</p>
<h1 id="四大隔离级别"><a href="#四大隔离级别" class="headerlink" title="四大隔离级别"></a>四大隔离级别</h1><p>Read uncommitted<br>Read committed<br>Repeatable read<br>Serializable  </p>
<p>(1)Read uncoommitted<br>    数据库不保证任何事务特性 可能出现脏读 不可重复读 虚读(幻读) 问题<br>    <strong>脏读</strong>:一个事务读取到了另一个事务未提交的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">	<span class="keyword">set</span> session transaction isolation level read uncoommitted;</span><br><span class="line">---------------</span><br><span class="line">	a: 1000</span><br><span class="line">	b: 1000</span><br><span class="line">---------------</span><br><span class="line">b:</span><br><span class="line">	start transaction;</span><br><span class="line">	update account <span class="keyword">set</span> money = money - 100 where name = 'b';</span><br><span class="line">	update account <span class="keyword">set</span> money = money + 100 where name = 'a';</span><br><span class="line"></span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	select * from account;</span><br><span class="line">---------------</span><br><span class="line">	a: 1100</span><br><span class="line">	b: 900</span><br><span class="line">---------------</span><br><span class="line">	commit;</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">	rollback;</span><br><span class="line"></span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	select * from account;</span><br><span class="line">---------------</span><br><span class="line">	a: 1000</span><br><span class="line">	b: 1000</span><br><span class="line">---------------</span><br><span class="line">	commit;</span><br></pre></td></tr></table></figure>
<p>(2)Read committed<br>保证部分隔离 可以防止脏读问题 但是具有不可重复读 和 虚读(幻读)问题<br><strong>不可重复读</strong>：一个事务读取到另一个事务已经提交的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">	<span class="keyword">set</span> session transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 1000 1000</span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">	start transaction;</span><br><span class="line">	select 活期 from account where name = 'a'; -- 活期存款1000</span><br><span class="line">	select 定期 from account where name = 'a'; -- 定期存款1000</span><br><span class="line">	select 固定 from account where name = 'a'; -- 固定存款1000</span><br><span class="line">-------------------------</span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	update account <span class="keyword">set</span> money = money - 1000 where name = 'a';</span><br><span class="line">	commit;</span><br><span class="line">-------------------------</span><br><span class="line">b:</span><br><span class="line">    select 活期 + 定期 + 固定 from account where name = 'a';</span><br><span class="line">-------------------------</span><br><span class="line">    总资产2000</span><br></pre></td></tr></table></figure>

<p>(3)Repeatable read<br>保证部分隔离 可以防止脏读 不可重复读问题 但是具有虚读(幻读)问题<br><strong>虚读(幻读)</strong>：一个事务读取全表数据时 读取到另一个事务向表中新增、删除操作提交的结果<br>**虚读(幻读)问题 有可能出现 有可能不出现 概率非常低</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation level Repeatable read;</span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 </span><br><span class="line">	b 1000</span><br><span class="line">-------------------------</span><br><span class="line">c：</span><br><span class="line">	start transaction;</span><br><span class="line">	select count(*) from account; -- 2人</span><br><span class="line">	select sum(money) from account; -- 2000元</span><br><span class="line">--------</span><br><span class="line">d：</span><br><span class="line">	start transaction;</span><br><span class="line">	insert into account values(d 4000);</span><br><span class="line">	commit;</span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 </span><br><span class="line">	b 1000</span><br><span class="line">	d 4000</span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line">select avg(money) from account; -- 2000元</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>(4)Serializable<br>保证完全隔离 可以防止脏读 不可重复读 虚读(幻读)问题<br>本质上是靠锁来实现的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">从安全性说：</span><br><span class="line">	Serializable &gt; Repeatable read &gt; Read committed &gt; Read uncommitted </span><br><span class="line">从效率说：</span><br><span class="line">	Read uncommitted &gt;Read committed &gt; Repeatable read &gt; Serializable</span><br></pre></td></tr></table></figure>
<p>真正在开发的过程中应该根据自身的业务需求选择一个在<strong>能防止想要防止的隔离性问题的级别</strong>中<strong>性能</strong>最好的一个隔离级别<br>mysql的<strong>默认</strong>隔离级别时 <strong>Repeatable read</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">查看数据库隔离级别：</span><br><span class="line">	select @@tx_isolation;</span><br><span class="line">设置数据库的隔离级别:</span><br><span class="line">	<span class="keyword">set</span> [session/global] transaction isolation level xxxxxx;</span><br></pre></td></tr></table></figure>

<h1 id="数据库中的锁机制"><a href="#数据库中的锁机制" class="headerlink" title="数据库中的锁机制"></a>数据库中的锁机制</h1><p>数据库中是有锁的，但是锁如果控制不好，对效率影响非常大，所以数据库设计者对锁做了特别的设计：  </p>
<table>
<thead>
<tr>
<th align="center">业务情况</th>
<th align="center">是否互斥</th>
</tr>
</thead>
<tbody><tr>
<td align="center">两个查询</td>
<td align="center">没有必要互斥</td>
</tr>
<tr>
<td align="center">两个修改</td>
<td align="center">必须互斥</td>
</tr>
<tr>
<td align="center">一个查询 另一个修改</td>
<td align="center">具体看情况 Serializable隔离级别下需要排斥 其他隔离级别不需要</td>
</tr>
</tbody></table>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁和共享锁可以共存，共享锁和排他锁不能共存<br>在非Serializable级别中查询不加任何锁 在Seralizable级别中查询加共享锁</p>
<h2 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h2><p> 排他锁和任何锁都不能共存<br> 在任意隔离级别下做增删改都加排他锁</p>
<p><strong>操作和锁的关系</strong><br>            1. 非Serializable级别,查询不加任何锁<br>            2. Serializable级别,查询加共享锁<br>            3. 任意隔离级别下,增删改都加排他锁</p>
<table>
<thead>
<tr>
<th>a(Rep)</th>
<th>b(Rep)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>都不加锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>不互斥</td>
<td>a不加锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>不互斥</td>
<td>a排他锁+b不加锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a(Ser)</th>
<th>b(Rep)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>a共享锁+b不加锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>互斥</td>
<td>a共享锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>不互斥</td>
<td>a排他锁+b不加锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a(Ser)</th>
<th>b(Ser)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>a共享锁+b共享锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>互斥</td>
<td>a共享锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>互斥</td>
<td>a排他锁+b共享锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<p>死锁：<br>    当两边都时Serializable隔离级别时<br>    两边都先进行查询 再尝试进行修改 则互相等待对方释放共享锁 都无法接着执行 造成了死锁<br>死锁的解决有两种办法：避免死锁 解决死锁<br>    mysql没有避免死锁，尝试检测死锁，发现死锁后，退出一方，执行另一方来解决了死锁。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>default关键字</title>
    <url>/2019/12/27/default%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>default关键字在Java中主要有两个用法，一个是在switch中执行，另一个是jdk1.8之后使用default关键字在接口中定义普通方法。</p>
<h1 id="default在Switch中的使用"><a href="#default在Switch中的使用" class="headerlink" title="default在Switch中的使用"></a>default在Switch中的使用</h1><p>default会在case匹配失败后执行</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ch = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是0"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是1"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是2"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              System.out.println(<span class="string">"默认值"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：<code>default</code><br>注：若case中没有break，则匹配成功后会继续执行代码，直到碰到break或return或者switch语句结束为止，这种情况下default可能会执行。</p>
<h1 id="default在接口中的使用（jdk1-8之后）"><a href="#default在接口中的使用（jdk1-8之后）" class="headerlink" title="default在接口中的使用（jdk1.8之后）"></a>default在接口中的使用（jdk1.8之后）</h1><p>在jdk1.8之后，接口中可以使用default定义普通方法。这样如果某些方法对于所有的子类都具有同样的实现，那么可以减少定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        是一个普通方法，jdk1.8之后才有</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">"我是接口1的普通方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMss</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是接口1的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        IMessage1 iMessage = <span class="keyword">new</span> MessageImpl1();</span><br><span class="line">        iMessage.print();</span><br><span class="line">        iMessage.getMsg();</span><br><span class="line">        IMessage1.getMss();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><code>MessageImpl1
我是接口1的普通方法
我是接口1的静态方法</code></p>
<h2 id="两个接口中默认方法冲突问题"><a href="#两个接口中默认方法冲突问题" class="headerlink" title="两个接口中默认方法冲突问题"></a>两个接口中默认方法冲突问题</h2><p>当一个类实现了两个接口，而两个接口中都有相同的默认方法，此时会出现什么情况呢？<br>我们再来定义一个新的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是接口2的普通方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让一个类同时实现接口1和接口2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl</span> <span class="keyword">implements</span> <span class="title">IMessage1</span> , <span class="title">IMessage2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器会报错<br><img src="https://img-blog.csdnimg.cn/20190804143036881.png" alt="IDEA中方法冲突提示"><br>此时编译器不知道应该从哪个接口中去调用默认方法，所以报错。<br>解决方法：<code>在实现类中重写该方法</code></p>
<h2 id="类与接口中定义了相同的方法"><a href="#类与接口中定义了相同的方法" class="headerlink" title="类与接口中定义了相同的方法"></a>类与接口中定义了相同的方法</h2><p>实现类1实现接口1并重写getMsg()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm from MessageImpl1 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类2继承实现类1并实现接口2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl2</span> <span class="keyword">extends</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若此时在实现类2中调用getMsg()方法，是执行MessageImpl1中的方法还是IMessage2中的呢？<br>执行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MessageImpl2 messageImpl2 = <span class="keyword">new</span> MessageImpl2();</span><br><span class="line">        messageImpl2.getMsg();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<code>I&#39;m from MessageImpl1</code><br>答：<strong>类优先级高于接口</strong>，所以执行实现类1中的方法。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>-java语法</tag>
      </tags>
  </entry>
</search>
