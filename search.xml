<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据库连接池</title>
    <url>/2020/05/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="为什么要使用连接池"><a href="#为什么要使用连接池" class="headerlink" title="为什么要使用连接池"></a>为什么要使用连接池</h2><p>数据库连接是一种关键的有限的昂贵资源。一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完关闭连接，这样造成系统性能低下。</p>
<a id="more"></a>

<p><img src="/2020/05/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/1.png" alt></p>
<p>数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于<br>连接池中连接数的并发请求，应该在请求队列中排队等候。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。</p>
<p><img src="/2020/05/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/2.png" alt></p>
<p>连接池技术尽可能多地重用了消耗的内存资源，大大节省了内存、提高了服务器服务效率、能够支持更多的客户服务。通过使用连接池，将大大提高程序的运行效率，同时，<br>我们可以通过自身的管理机制来剪视数据库连接的数量、使用情况等。</p>
<h2 id="传统的连接机制与数据库连接池运行机制的区别"><a href="#传统的连接机制与数据库连接池运行机制的区别" class="headerlink" title="传统的连接机制与数据库连接池运行机制的区别"></a>传统的连接机制与数据库连接池运行机制的区别</h2><h3 id="不使用连接池流程"><a href="#不使用连接池流程" class="headerlink" title="不使用连接池流程"></a>不使用连接池流程</h3><p>下面以访问MySQL为例，执行一个SQL命令，如果不使用连接池，需要经过哪些流程。</p>
<p><img src="/2020/05/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/3.png" alt></p>
<ol>
<li>TCP建立连接的三次握手；</li>
<li>MySQL认证的三次握手；</li>
<li>真正的SQL执行；</li>
<li>MySQL的关闭；</li>
<li>TCP的四次握手关闭。</li>
</ol>
<p>优点:</p>
<p>· 实现简单</p>
<p>缺点：</p>
<p>· 网络IO较多<br>· 数据库的负载较高<br>· 响应时间较长及QPS(吞吐量)较低<br>· 应用频繁的创建连接和关闭连接，导致临时对象较多，GC频繁<br>· 在关闭连接后，会出现大量TIME_WAIT的TCP状态(在2个MSL(Multilayer Switching Protocol多层交换)之后关闭)  </p>
<h3 id="使用连接池流程"><a href="#使用连接池流程" class="headerlink" title="使用连接池流程"></a>使用连接池流程</h3><p><img src="/2020/05/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/4.png" alt></p>
<p>第一次访问的时候需要建立连接，但是之后的范围跟，均会复用之前创建的连接，直接执行SQL语句。</p>
<p>优点:<br>· 减少了网络开销<br>· 提升了系统性能<br>· 没有了TIME_WAIT状态</p>
<h2 id="数据库连接池的工作原理"><a href="#数据库连接池的工作原理" class="headerlink" title="数据库连接池的工作原理"></a>数据库连接池的工作原理</h2><h3 id="连接池的建立"><a href="#连接池的建立" class="headerlink" title="连接池的建立"></a>连接池的建立</h3><p>一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，<br>这样避免了连接随意建立和关闭造成的系统开销。</p>
<h3 id="连接池的管理"><a href="#连接池的管理" class="headerlink" title="连接池的管理"></a>连接池的管理</h3><p>当客户请求数据库连接时，首先查看连接池中是否由空闲连接，如果存在空闲连接，则将连接分配给客户；如果没有空闲连接，则查看当前所开的连接数是否<br>已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则跑出异常给客户。<br>当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其它客户服务。该策略保证了数据库连接<br>的有效复用，避免频繁的建立、释放连接带来的系统资源开销。</p>
<h3 id="连接池的关闭"><a href="#连接池的关闭" class="headerlink" title="连接池的关闭"></a>连接池的关闭</h3><p>当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。</p>
<h2 id="连接池需要注意的点"><a href="#连接池需要注意的点" class="headerlink" title="连接池需要注意的点"></a>连接池需要注意的点</h2><ol>
<li>并发问题</li>
</ol>
<p>java使用synchronized关键字保证线程同步。</p>
<ol start="2">
<li>事务处理</li>
</ol>
<p>使用每一个事务独占一个连接来处理，虽然有点浪费连接池资源但是可以大大降低事务处理的复杂性。</p>
<ol start="3">
<li>连接池的分配与释放</li>
</ol>
<p>连接池的分配与释放，对系统性能有很大影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。<br>对于连接的管理可以使用一个List。即把已经创建的连接都放入List中统一管理。每当用户请求一个连接时，系统检查这个List中有没有可以分配的连接。<br>如果有就把那个最合适的连接分配给他，如果没有就抛出一个异常给他。</p>
<ol start="4">
<li>连接池的配置和维护</li>
</ol>
<p>系统可采取设置最小连接数和最大连接数等参数来空指连接池中的连接。最小连接数时系统启动时连接池所创建的连接数，如果创建过多，则系统启动就慢，<br>但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。要根据系统的具体访问量来决定最大连接数。</p>
<p>确保最小连接数：有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充响应数量的新连接，以保证<br>连接池的正常运转。静态是发现空闲连接不够时再去检查。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>《On-Java8》5-初始化和清理</title>
    <url>/2020/04/30/%E3%80%8AOn-Java8%E3%80%8B5-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<h2 id="利用构造器保证初始化"><a href="#利用构造器保证初始化" class="headerlink" title="利用构造器保证初始化"></a>利用构造器保证初始化</h2><p>在 Java 中，类的设计者通过构造器保证每个对象的初始化。如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。</p>
<p>构造器没有返回值，它是一种特殊的方法。但它和返回类型为 void 的普通方法不同，普通方法可以返回空值，你还能选择让它返回别的类型；而构造器没有返回值，却同时也没有给你选择<br>的余地（new 表达式虽然返回了刚创建的对象的引用，但构造器本身却没有返回任何值）。</p>
<h3 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h3><p>构造器名称与类名相同</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><h3 id="区分重载方法"><a href="#区分重载方法" class="headerlink" title="区分重载方法"></a>区分重载方法</h3><p>每个被重载的方法必须有独一无二的参数列表。</p>
<h3 id="返回值的重载"><a href="#返回值的重载" class="headerlink" title="返回值的重载"></a>返回值的重载</h3><p>“为什么只能通过类名和参数列表，不能通过方法的返回值区分方法呢?”</p>
<p>你可以调用一个方法且忽略返回值。这叫做调用一个函数的副作用，因为你不在乎返回值，只是想利用方法做些事。所以如果你直接调用 f()，Java 编译器就不知道你想调用哪个方法，阅读<br>者也不明所以。</p>
<h2 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h2><p>如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器。但是,一旦你显式地定义了构造器（无论有参还是无参），编译器就不会自动为你创建无参构造器。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this 关键字只能在非静态方法内部使用。当你调用一个对象的方法时，this 生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用其他该类中的方法<br>，不要使用 this，直接调用即可，this 自动地应用于其他方法上了。 this 关键字只用在一些必须显式使用当前对象引用的特殊场合。例如，用在 return 语句中返回对当前对象的引用。</p>
<p>this 关键字在向其他方法传递当前对象时也很有用。</p>
<h3 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h3><p>当你在一个类中写了多个构造器，有时你想在一个构造器中调用另一个构造器来避免代码重复。你通过 this 关键字实现这样的调用。<br>在一个构造器中，当你给 this 一个参数列表时，它是另一层意思。它通过最直接的方式显式地调用匹配参数列表的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Flower.java</span></span><br><span class="line"><span class="comment">// Calling constructors with "this"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> petalCount = <span class="number">0</span>;</span><br><span class="line">    String s = <span class="string">"initial value"</span>;</span><br><span class="line"></span><br><span class="line">    Flower(<span class="keyword">int</span> petals) &#123;</span><br><span class="line">        petalCount = petals;</span><br><span class="line">        System.out.println(<span class="string">"Constructor w/ int arg only, petalCount = "</span> + petalCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower(String ss) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Constructor w/ string arg only, s = "</span> + ss);</span><br><span class="line">        s = ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower(String s, <span class="keyword">int</span> petals) &#123;</span><br><span class="line">        <span class="keyword">this</span>(petals);</span><br><span class="line">        <span class="comment">//- this(s); // Can't call two!</span></span><br><span class="line">        <span class="keyword">this</span>.s = s; <span class="comment">// Another use of "this"</span></span><br><span class="line">        System.out.println(<span class="string">"String &amp; int args"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower() &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">        System.out.println(<span class="string">"no-arg constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printPetalCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- this(11); // Not inside constructor!</span></span><br><span class="line">        System.out.println(<span class="string">"petalCount = "</span> + petalCount + <span class="string">" s = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Flower x = <span class="keyword">new</span> Flower();</span><br><span class="line">        x.printPetalCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从构造器 Flower(String s, int petals) 可以看出，其中只能通过 this 调用一次构造器。另外，必须首先调用构造器，否则编译器会报错。这个例子同样展示了<br> this 的另一个用法。参数列表中的变量名 s 和成员变量名 s 相同，会引起混淆。你可以通过 this.s 表明你指的是成员变量 s，从而避免重复。你经常会在 Java<br> 代码中看到这种用法，同时本书中也会多次出现这种写法。在 printPetalCount() 方法中，编译器不允许你在一个构造器之外的方法里调用构造器。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static 方法中不会存在 this.静态方法是为类而创建的，不需要任何对象。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="finalize-的用途"><a href="#finalize-的用途" class="headerlink" title="finalize()的用途"></a>finalize()的用途</h3><p>当对某个对象不感兴趣时——也就是它将被清理了，这个对象应该处于某种状态，这种状态下它占用的内存可以被安全地释放掉。例如，如果对象代表了一个打开的文件，<br>在对象被垃圾回收之前程序员应该关闭这个文件。只要对象中存在没有被适当清理的部分，程序就存在很隐晦的 bug。finalize() 可以用来最终发现这个情况，尽管<br>它并不总是被调用。如果某次 finalize() 的动作使得 bug 被发现，那么就可以据此找出问题所在——这才是人们真正关心的。以下是个简单的例子，示范了<br>finalize() 的可能使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/TerminationCondition.java</span></span><br><span class="line"><span class="comment">// Using finalize() to detect a object that</span></span><br><span class="line"><span class="comment">// hasn't been properly cleaned up</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> checkedOut = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Book(<span class="keyword">boolean</span> checkOut) &#123;</span><br><span class="line">        checkedOut = checkOut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkedOut = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkedOut) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Error: checked out"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Normally, you'll also do this:</span></span><br><span class="line">        <span class="comment">// super.finalize(); // Call the base-class version</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminationCondition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Book novel = <span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// Proper cleanup:</span></span><br><span class="line">        novel.checkIn();</span><br><span class="line">        <span class="comment">// Drop the reference, forget to clean up:</span></span><br><span class="line">        <span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// Force garbage collection &amp; finalization:</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">1</span>); <span class="comment">// One second delay</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的 Book 对象在被垃圾回收之前必须被登记。但在 main() 方法中，有一本书没有登记。要是没有 finalize() 方法来验证终结条件，将会很难发现这个 bug。</p>
<h3 id="垃圾回收器如何工作"><a href="#垃圾回收器如何工作" class="headerlink" title="垃圾回收器如何工作"></a>垃圾回收器如何工作</h3><p>见Java垃圾回收</p>
<h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2><p>Java 尽量保证所有变量在使用前都能得到恰当的初始化。</p>
<h3 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h3><h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3><p>无论创建多少个对象，静态数据都只占用一份存储区域。static 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。如果一个字段是静态的基本类型，<br>你没有初始化它，那么它就会获得基本类型的标准初值。如果它是对象引用，那么它的默认初值就是 null。</p>
<p>概括一下创建对象的过程，假设有个名为 Dog 的类：</p>
<ol>
<li>即使没有显式地使用 static 关键字，构造器实际上也是静态方法。所以，当首次创建 Dog 类型的对象或是首次访问 Dog 类的静态方法或属性时，Java 解释<br>器必须在类路径中查找，以定位 Dog.class。</li>
<li>当加载完 Dog.class 后（后面会学到，这将创建一个 Class 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 Class 对象时<br>初始化一次。</li>
<li>当用 new Dog() 创建对象时，首先会在堆上为 Dog 对象分配足够的存储空间。</li>
<li>分配的存储空间首先会被清零，即会将 Dog 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 null。</li>
<li>执行所有出现在字段定义处的初始化动作。</li>
<li>执行构造器。你将会在”复用”这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。</li>
</ol>
<h3 id="显示的静态初始化"><a href="#显示的静态初始化" class="headerlink" title="显示的静态初始化"></a>显示的静态初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spoon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与其他静态初始化动作一样，这段代码仅执行一次：当首次创建这个类的对象或首次访问这个类的静态成员（甚至不需要创建该类的对象）时。</p>
<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>###动态数组创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/ArrayNew.java</span></span><br><span class="line"><span class="comment">// Creating arrays with new</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line">        System.out.println(<span class="string">"length of a = "</span> + a.length);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/NewVarArgs.java</span></span><br><span class="line"><span class="comment">// Using array syntax to create variable argument lists</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewVarArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj: args) &#123;</span><br><span class="line">            System.out.print(obj + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Can take individual elements:</span></span><br><span class="line">        printArray(<span class="number">47</span>, (<span class="keyword">float</span>) <span class="number">3.14</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="number">47</span>, <span class="number">3.14F</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);</span><br><span class="line">        printArray(<span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A());</span><br><span class="line">        <span class="comment">// Or an array:</span></span><br><span class="line">        printArray((Object[]) <span class="keyword">new</span> Integer[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        printArray(); <span class="comment">// Empty list is OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了可变参数，你就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你填充数组。你获取的仍然是一个数组，这就是为什么 printArray() 可以使用 for-in 迭代数组的原因。<br>但是，这不仅仅只是从元素列表到数组的自动转换。注意程序的倒数第二行，一个 Integer 数组（通过自动装箱创建）被转型为一个 Object 数组（为了移除编译器的警告），并且传递给了<br>printArray()。显然，编译器会发现这是一个数组，不会执行转换。因此，如果你有一组事物，可以把它们当作列表传递，而如果你已经有了一个数组，该方法会把它们当作可变参数列表来接受。<br>程序的最后一行表明，可变参数的个数可以为 0。</p>
<p>可变参数列表使得方法重载更加复杂了，尽管乍看之下似乎足够安全：但是如果调用不含参数的 f()，编译器就无法知道应该调用哪个方法了。你应该总是在重载方法的一个版本上使用可变参数列<br>表，或者压根不用它.</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>On Java8读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《On-Java8》4-控制流</title>
    <url>/2020/04/30/%E3%80%8AOn-Java8%E3%80%8B4-%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<h2 id="true和false"><a href="#true和false" class="headerlink" title="true和false"></a>true和false</h2><p>如果想在布尔测试中使用一个非布尔值，那么首先需要使用条件表达式来产生 boolean 类型的结果，例如 if(a != 0)。</p>
<a id="more"></a>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Boolean-expression) </span><br><span class="line">    “statement”</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  “statement”</span><br></pre></td></tr></table></figure>

<p>布尔表达式（Boolean-expression）必须生成 boolean 类型的结果，执行语句 statement 既可以是以分号 ; 结尾的一条简单语句，<br>也可以是包含在大括号 {} 内的的复合语句 —— 封闭在大括号内的一组简单语句。</p>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>执行语句会在每一次循环前，判断布尔表达式返回值是否为 true。下例可产生随机数，直到满足特定条件。</p>
<h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><p>while 和 do-while 之间的唯一区别是：即使条件表达式返回结果为 false， do-while 语句也至少会执行一次。 在 while 循环体<br>中，如布尔表达式首次返回的结果就为 false，那么循环体内的语句不会被执行。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(initialization; Boolean-expression; step)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>初始化 (initialization) 表达式、布尔表达式 (Boolean-expression) ，或者步进 (step) 运算，都可以为空。每次迭代之前都会判<br>断布尔表达式的结果是否成立。一旦计算结果为 false，则跳出 for 循环体并继续执行后面代码。 每次循环结束时，都会执行一次步进。</p>
<h4 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h4><p>在 Java 中逗号运算符（这里并非指我们平常用于分隔定义和方法参数的逗号分隔符）仅有一种用法：在 for 循环的初始化和步进控制中定义<br>多个变量。我们可以使用逗号分隔多个语句，并按顺序计算这些语句。<strong>注意：</strong>要求定义的变量类型相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/CommaOperator.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommaOperator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = i + <span class="number">10</span>; i &lt; <span class="number">5</span>; i++, j = i * <span class="number">2</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"i = "</span> + i + <span class="string">" j = "</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-in语法"><a href="#for-in语法" class="headerlink" title="for-in语法"></a>for-in语法</h3><p>Java 5 引入了更为简洁的“增强版 for 循环”语法来操纵数组和集合。</p>
<h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>return 关键字有两方面的作用：1.指定一个方法返回值 (在方法返回类型非 void 的情况下)；2.退出当前方法，并返回作用 1 中值.</p>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>在任何迭代语句的主体内，都可以使用 break 和 continue 来控制循环的流程。 其中，break 表示跳出当前循环体。而 continue<br>表示停止本次循环，开始下一次循环。</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>“标签”是后面跟一个冒号的标识符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label1:</span><br></pre></td></tr></table></figure>

<p>对 Java 来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方 —— 在标签和循环之间置入任何语<br>句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环或者一个开关。这是由于 break 和 continue<br>关键字通常只中断当前循环，但若搭配标签一起使用，它们就会中断并跳转到标签所在的地方开始执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label1:</span><br><span class="line">outer-iteration &#123; </span><br><span class="line">  inner-iteration &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">break</span>; <span class="comment">// [1] </span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">continue</span>; <span class="comment">// [2] </span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">continue</span> label1; <span class="comment">// [3] </span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">break</span> label1; <span class="comment">// [4] </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[1] break 中断内部循环，并在外部循环结束。 [2] continue 移回内部循环的起始处。但在条件 3 中，continue label1 却同<br>时中断内部循环以及外部循环，并移至 label1 处。 [3] 随后，它实际是继续循环，但却从外部循环开始。 [4] break label1 也<br>会中断所有循环，并回到 label1 处，但并不重新进入循环。也就是说，它实际是完全中止了两个循环。</p>
<ol>
<li>简单的一个 continue 会退回最内层循环的开头（顶部），并继续执行</li>
<li>带有标签的 continue 会到达标签的位置，并重新进入紧接在那个标签后面的循环。</li>
<li>break 会中断当前循环，并移离当前标签的末尾。</li>
<li>带标签的 break 会中断当前循环，并移离由那个标签指示的循环的末尾。</li>
</ol>
<p>大家要记住的重点是：在 Java 里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中 break 或 continue。</p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>switch 有时也被划归为一种选择语句。根据整数表达式的值，switch 语句可以从一系列代码中选出一段去执行。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>On Java8读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《On-Java8》3-运算符</title>
    <url>/2020/04/27/%E3%80%8AOn-Java8%E3%80%8B3-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>运算符的赋值是由符号 = 完成的。获取 = 右边的值赋给左边的变量。右边可以是任何常量、变量或者可产生一个返回值的表达式。但左<br>边必须是一个明确的、已命名的变量。<br>基本类型的赋值是直接的(此后对原值的修改不会影响到被赋值的基本类型)，而不像对象，赋予的只是其内存的引用(操作的还是同一个<br>对象)。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/Assignment.java</span></span><br><span class="line"><span class="comment">// Assignment with objects is a bit tricky</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Assignment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tank t1 = <span class="keyword">new</span> Tank();</span><br><span class="line">        Tank t2 = <span class="keyword">new</span> Tank();</span><br><span class="line">        t1.level = <span class="number">9</span>;</span><br><span class="line">        t2.level = <span class="number">47</span>;</span><br><span class="line">        System.out.println(<span class="string">"1: t1.level: "</span> + t1.level +</span><br><span class="line">            <span class="string">", t2.level: "</span> + t2.level);</span><br><span class="line">        t1 = t2;</span><br><span class="line">        System.out.println(<span class="string">"2: t1.level: "</span> + t1.level +</span><br><span class="line">            <span class="string">", t2.level: "</span> + t2.level);</span><br><span class="line">        t1.level = <span class="number">27</span>;</span><br><span class="line">        System.out.println(<span class="string">"3: t1.level: "</span> + t1.level +</span><br><span class="line">            <span class="string">", t2.level: "</span> + t2.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个简单的 Tank 类，在 main() 方法创建了两个实例对象。 两个对象的 level 属性分别被赋予不同的值。 然后，t2 的值被赋予<br>给 t1。在许多编程语言里，预期的结果是 t1 和 t2 的值会一直相对独立。但是，在 Java 中，由于赋予的只是对象的引用，改变 t1<br>也就改变了 t2。 这是因为 t1 和 t2 此时指向的是堆中同一个对象。（t1 原始对象的引用在 t2 赋值给其时丢失，它引用的对象会在垃<br>圾回收时被清理）。</p>
<p>这种现象通常称为别名（aliasing），这是 Java 处理对象的一种基本方式.</p>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>Java 的基本算术运算符与其他大多编程语言是相同的。其中包括加号 +、减号 -、除号 /、乘号 * 以及取模 %（从整数除法中获得余数）<br>。整数除法会直接砍掉小数，而不是进位.</p>
<h3 id="随机数产生方法"><a href="#随机数产生方法" class="headerlink" title="随机数产生方法"></a>随机数产生方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br></pre></td></tr></table></figure>

<p>括号中的参数为“种子(seed)”（随机数生成器的初始化值，其始终为特定种子值产生相同的序列）。每次执行都会产生相同随机数序列。不带<br>参数的Random 对象会利用当前的时间用作随机数生成器的“种子”。</p>
<h2 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h2><p>++ – 。</p>
<p>对于前递增和前递减（如 ++a 或 –a），会先执行递增/减运算，再返回值。而对于后递增和后递减（如 a++ 或 a–），会先返回值，再<br>执行递增/减运算。</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符包括小于 &lt;，大于 &gt;，小于或等于 &lt;=，大于或等于 &gt;=，等于 == 和不等于 ！=。</p>
<h3 id="测试对象等价"><a href="#测试对象等价" class="headerlink" title="测试对象等价"></a>测试对象等价</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/Equivalence.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer n1 = <span class="number">47</span>;</span><br><span class="line">        Integer n2 = <span class="number">47</span>;</span><br><span class="line">        System.out.println(n1 == n2);</span><br><span class="line">        System.out.println(n1 != n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>== 和 != 比较的是对象引用，所以输出实际上应该是先输出 false，再输出 true（如果你把 47 改成 128，那么打印的结果就<br>是这样，因为 Integer 内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，所以 [-128, 127] 之间的值用 ==<br>和 != 比较也能能到正确的结果，但是不推荐用关系运算符比较).</p>
<p>对象的内容比较应该使用equals.</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>每个逻辑运算符 &amp;&amp; （AND）、||（OR）和 !（非）根据参数的逻辑关系生成布尔值 true 或 false。</p>
<h3 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h3><p>逻辑运算符支持一种称为“短路”（short-circuiting）的现象。整个表达式会在运算到可以明确结果时就停止并返回结果，这意味着该逻<br>辑表达式的后半部分不会被执行到。</p>
<p>运用“短路”可以节省部分不必要的运算，从而提高程序潜在的性能。</p>
<h2 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h2><p>对于 Long 型数值，结尾使用大写 L 或小写 l 皆可（不推荐使用 l，因为容易与阿拉伯数值 1 混淆）。大写 F 或小写 f 表示<br>float 浮点数。大写 D 或小写 d 表示 double 双精度。</p>
<p>十六进制（以 16 为基数），适用于所有整型数据类型，由前导 0x 或 0X 表示，后跟 0-9 或 a-f （大写或小写）。</p>
<p>八进制（以 8 为基数）由 0~7 之间的数字和前导零 0 表示。</p>
<p>Java 7 引入了二进制的字面值常量，由前导 0b 或 0B 表示，它可以初始化所有的整数类型。</p>
<p>使用整型数值类型时，显示其二进制形式会很有用。在 Long 型和 Integer 型中这很容易实现，调用其静态的 toBinaryString() 方<br>法即可。 但是请注意，若将较小的类型传递给 Integer.tobinarystring() 时，类型将自动转换为 int。</p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>Java 7 中有一个深思熟虑的补充：我们可以在数字字面量中包含下划线 _，以使结果更清晰。这对于大数值的分组特别有用。</p>
<ol>
<li><p>仅限单 _，不能多条相连</p>
</li>
<li><p>数值开头和结尾不允许出现 _</p>
</li>
<li><p>F、D 和 L的前后禁止出现 _</p>
</li>
<li><p>二进制前导 b 和 十六进制 x 前后禁止出现 _</p>
<p>Java 用 %n 实现的可以忽略平台间差异而生成适当的换行符，但只有当你使用 System.out.printf() 或 System.out.format() 时<br>。对于 System.out.println()，我们仍然必须使用 \n；如果你使用 %n，println() 只会输出 %n 而不是换行符。</p>
</li>
</ol>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>若两个输入位都是 1，则按位“与运算符” &amp; 运算后结果是 1，否则结果是 0。若两个输入位里至少有一个是 1，则按位“或运算符” | 运<br>算后结果是 1；只有在两个输入位都是 0 的情况下，运算结果才是 0。若两个输入位的某一个是 1，另一个不是 1，那么按位“异或运算符<br>” ^ 运算后结果才是 1。按位“非运算符” ~ 属于一元运算符；它只对一个自变量进行操作（其他所有运算符都是二元运算符）。按位非运<br>算后结果与输入位相反。例如输入 0，则输出 1；输入 1，则输出 0。</p>
<h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>移位运算符面向的运算对象也是二进制的“位”。它们只能用于处理整数类型（基本类型的一种）。左移位运算符 &lt;&lt; 能将其左边的运算对象<br>向左移动右侧指定的位数（在低位补 0）。右移位运算符 &gt;&gt; 则相反。右移位运算符有“正”、“负”值：若值为正，则在高位插入 0；若值为<br>负，则在高位插入 1。Java 也添加了一种“不分正负”的右移位运算符（&gt;&gt;&gt;），它使用了“零扩展”（zero extension）：无论正负，都在<br>高位插入 0。</p>
<p>如果移动 char、byte 或 short，则会在移动发生之前将其提升为 int，结果为 int。仅使用右值（rvalue）的 5 个低阶位。这可以防<br>止我们移动超过 int 范围的位数。</p>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>三元运算符中的类型应该一致，否则当值为null时会报空指针异常。</p>
<h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p> +<br> 我们经常会看到一个空字符串 “” 跟着一个基本类型的数据。这样可以隐式地将其转换为字符串，以代替繁琐的显式调用方法（如这里可以<br> 使用 Integer.toString()）。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="截断和舍入"><a href="#截断和舍入" class="headerlink" title="截断和舍入"></a>截断和舍入</h3><p>从 float 和 double 转换为整数值时，小数位将被截断。若你想对结果进行四舍五入，可以使用 java.lang.Math 的 round() 方法</p>
<h3 id="类型提升"><a href="#类型提升" class="headerlink" title="类型提升"></a>类型提升</h3><p>通常，表达式中最大的数据类型是决定表达式结果的数据类型。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>On Java8读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《On-Java8》2-万物皆对象</title>
    <url>/2020/04/22/%E3%80%8AOn-Java8%E3%80%8B2-%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="对象操纵"><a href="#对象操纵" class="headerlink" title="对象操纵"></a>对象操纵</h2><p>Java利用万物皆对象的思想和单一一致的语法方式来简化问题。虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的引用。</p>
<a id="more"></a>

<p>创建引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s;</span><br></pre></td></tr></table></figure>

<p>创建引用同时进行初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"jerry"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>“引用”用来关联“对象”。在Java中，通常我们使用new操作符来创建一个新对象。new关键字表示：创建一个新的对象实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"jerry"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><ol>
<li>寄存器(Registers) 最快的存储区域，位于CPU内部。寄存器数量十分有限，按照需求进行分配。我们没有直接的控制前，也无法在自己<br>的程序里找到寄存器存在的踪迹。</li>
<li>栈内存(Stack) 存在于常规内存RAM(随机访问存储器，Random Access Memory)区域中，可通过栈指针获得处理器的直接支持。栈指针<br>下移分配内存，上移释放内存，这是一种快速有效的内存分配方法，速度仅次于寄存器。创建程序时，Java系统必须准确的直到栈内保存的所<br>有项的生命周期。这种约束限制了系统的灵活性。因此，栈内存一般存放对象的引用，对象是保存在堆内存中的。</li>
<li>堆内存(Heap) 这是一种通用的内存池(也在RAM区域)，所有Java对象都存在其中。</li>
<li>常量存储(Constant storage) 常量值通常直接放在程序代码中，因为它们永远不会改变，如需严格保护，可以存放在ROM(只读存储器，<br>Read Only Memory)中。</li>
<li>非RAM存储(Non-RAM storage) 数据完全存在于程序之外，在程序未运行及脱离程序控制后依然存在。</li>
</ol>
<ul>
<li>序列化对象：对象被转换为字节流，通常被发送到另一台机器；</li>
<li>持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。</li>
</ul>
<p>这些存储的方式都是将对象的转存于另一个介质中，并在需要时恢复成常规的、基于RAM的对象。</p>
<h3 id="基本类型的存储"><a href="#基本类型的存储" class="headerlink" title="基本类型的存储"></a>基本类型的存储</h3><p>Java的基本类型被存放在栈内存中。</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">大小</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
<th align="center">包装类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16 bits</td>
<td align="center">Unicode 0</td>
<td align="center">Unicode $2^{16}$ -1</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">8 bits</td>
<td align="center">-128</td>
<td align="center">+127</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16 bits</td>
<td align="center">-$2^{15}$</td>
<td align="center">+$2^{15}$-1</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32 bits</td>
<td align="center">-$2^{31}$</td>
<td align="center">+$2^{31}$-1</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64 bits</td>
<td align="center">-$2^{63}$</td>
<td align="center">+$2^{63}$-1</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32 bits</td>
<td align="center">IEEE754</td>
<td align="center">IEEE754</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64 bits</td>
<td align="center">IEEE754</td>
<td align="center">IEEE754</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Void</td>
</tr>
</tbody></table>
<p>基本类型有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类。</p>
<h3 id="高精度数值"><a href="#高精度数值" class="headerlink" title="高精度数值"></a>高精度数值</h3><p>BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。 BigDecimal 支持任意精度的定<br>点数字。例如，可用它进行精确的货币计算。</p>
<h3 id="数组的存储"><a href="#数组的存储" class="headerlink" title="数组的存储"></a>数组的存储</h3><p>在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下<br>标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。</p>
<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是</span></span><br><span class="line"><span class="comment">* 跨越多行的</span></span><br><span class="line"><span class="comment">* 注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是跨越多</span></span><br><span class="line"><span class="comment">行的注释 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这是单行注释</span><br></pre></td></tr></table></figure>

<h2 id="对象清理"><a href="#对象清理" class="headerlink" title="对象清理"></a>对象清理</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在 Java 中，你不能执行以下操作，即使这在 C 和 C++ 中是合法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">96</span>; <span class="comment">// Illegal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中， Java 编译器会在提示变量 x 已经被定义过了。</p>
<h3 id="对象作用域"><a href="#对象作用域" class="headerlink" title="对象作用域"></a>对象作用域</h3><p>Java 对象与基本类型具有不同的生命周期。当我们使用 new 关键字来创建 Java 对象时，它的生命周期将会超出作用域。<br>new出来的对象会一直存在，直到Java垃圾收集器检查并清除。</p>
<h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><h3 id="基本类型默认值"><a href="#基本类型默认值" class="headerlink" title="基本类型默认值"></a>基本类型默认值</h3><h3 id="方法使用"><a href="#方法使用" class="headerlink" title="方法使用"></a>方法使用</h3><p>在 Java 中，方法决定对象能接收哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[返回类型] [方法名](<span class="comment">/*参数列表*/</span>)&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><p>方法的返回类型表明了当你调用它时会返回的结果类型。参数列表则显示了可被传递到方法内部的参数类型及名称。方法名和参数列表统称<br>为方法签名（signature of the method）。签名作为方法的唯一标识。</p>
<h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><p>方法参数列表指定了传递给方法的信息。</p>
<h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><h3 id="命名可见性"><a href="#命名可见性" class="headerlink" title="命名可见性"></a>命名可见性</h3><p>为一个类库生成一个明确的名称，Java 创建者希望我们反向使用自己的网络域名，因为域名通常是唯一的。</p>
<h3 id="使用其它组件"><a href="#使用其它组件" class="headerlink" title="使用其它组件"></a>使用其它组件</h3><p>你必须通过使用 import 关键字来告诉 Java 编译器具体要使用的类。</p>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>类是对象的外观及行为方式的描述。通常只有在使用 new 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这<br>种方式在两种情况下是不足的。</p>
<ol>
<li>有时你只想为特定字段（注：也称为属性、域）分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。</li>
<li>创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。</li>
</ol>
<p>static 关键字（从 C++ 采用）就符合上述两点要求。当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例<br> 。 即使我们从未创建过该类的对象，也可以调用其静态方法或访问其静态字段。</p>
<h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><p>ava 编程语言编码规范（Code Conventions for the Java Programming Language）要求类名的首字母大写。 如果类名是由多个<br>单词构成的，则每个单词的首字母都应大写（不采用下划线来分隔）。</p>
<p>有时称这种命名风格叫“驼峰命名法”。对于几乎所有其他方法，字段（成员变量）和对象引用名都采用驼峰命名的方式，但是它们的首字母<br>不需要大写。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>On Java8读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《On Java8》1-对象的概念</title>
    <url>/2020/04/08/%E3%80%8AOn-Java8%E3%80%8B1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>面向对象编程(Object-Oriented Programming OOP)是一种编程思维方式和编码架构。</p>
<a id="more"></a>

<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>我们将问题空间中的元素以及它们在解决方案空间的表示称作“对象”(<strong>Object</strong>)。这与现实世界的“对象”和“物体”相似，它们都有自己的特征和行为。</p>
<ol>
<li>万物皆对象</li>
<li>程序是一组对象，通过消息传递来告诉彼此该做什么</li>
<li>每个对象都有自己的存储空间，可容纳其它对象</li>
<li>每个对象都有一种类型</li>
<li>同一类所有对象都能接收相同的消息</li>
</ol>
<p>一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态),方法(产生行为),并彼此区分(每个对象在内存中都有唯一的地址).</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>如何在“问题空间”（问题实际存在的地方）的元素与“方案空间”（对实际问题进行建模的地方，如计算机）的元素之间建立理想的“一对一”的映射关系。</p>
<p>我们向对象发出的请求是通过它的“接口”定义的，对象的“类型”或“类”则规定了它的接口形式。</p>
<p><img src="/2020/04/08/%E3%80%8AOn-Java8%E3%80%8B1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/1.png" alt></p>
<p>上图遵循 UML（Unified Modeling Language，统一建模语言）的格式。每个类由一个框表示，框的顶部有类型名称，框中间部分是要描述的任何数据成员，方法（属于此对象的方法，它们接收任何发送到该对象的消息）在框的底部。通常，只有类的名称和公共方法在 UML 设计图中显示，因此中间部分未显示，如本例所示。如果你只对类名感兴趣，则也不需要显示方法信息。</p>
<h2 id="服务提供"><a href="#服务提供" class="headerlink" title="服务提供"></a>服务提供</h2><p>在开发或理解程序设计时，我们可以将对象看成是“服务提供者”。</p>
<p>软件设计的基本原则是高内聚：每个组件的内部作用明确，功能又紧密相关。在良好的面向对象设计中，每个对象功能单一且高效，这样的程序设计可以提高我们代码的复用性。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ol>
<li><p><strong>public</strong>（公开）表示任何人都可以访问和使用该元素；</p>
</li>
<li><p><strong>private</strong>（私有）除了类本身和类内部的方法，外界无法直接访问该元素。private 是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误；</p>
</li>
<li><p><strong>protected</strong>（受保护）类似于 private，区别是子类（下一节就会引入继承的概念）可以访问 protected 的成员，但不能访问 private 成员；</p>
</li>
<li><p><strong>default</strong>（默认）如果你不使用前面的三者，默认就是 default 访问权限。default 被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。</p>
</li>
</ol>
<h2 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h2><ul>
<li>组合（Composition）经常用来表示“拥有”关系（has-a relationship）。例如，“汽车拥有引擎”。</li>
<li>聚合（Aggregation）动态的组合。</li>
</ul>
<p><img src="/2020/04/08/%E3%80%8AOn-Java8%E3%80%8B1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/2.png" alt></p>
<p>上图中实心三角形指向“ Car ”表示 组合 的关系；如果是 聚合 关系，可以使用空心三角形。</p>
<p>聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件。这个区别可以用来区分某个关联关系到底是组合还是聚合。两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类。但我们若能利用现成的数据类型，对其进行“克隆”，再根据情况进行添加和修改，情况就显得理想多了。“继承”正是针对这个目标而设计的。但继承并不完全等价于克隆。在继承过程中，若原始类（正式名称叫作基类、超类或父类）发生了变化，修改过的“克隆”类（正式名称叫作继承类或者子类）也会反映出这种变化。</p>
<p>创建基类以表示思想的核心。从基类中派生出其他类型来表示实现该核心的不同方式。</p>
<p><img src="/2020/04/08/%E3%80%8AOn-Java8%E3%80%8B1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/3.png" alt></p>
<p>有两种方法可以区分新的派生类与原始的基类。</p>
<ol>
<li>在派生类中添加新方法。</li>
<li>重写(Overriding)方法。</li>
</ol>
<h3 id="“是一个”与”像是一个”的关系"><a href="#“是一个”与”像是一个”的关系" class="headerlink" title="“是一个”与”像是一个”的关系"></a>“是一个”与”像是一个”的关系</h3><ol>
<li>继承只覆盖父类的方法，具有相同的接口。这样的话可以用一个子类完全替代父类，这种关系称为”是一个(is-a)“;</li>
<li>有时在子类中添加了新的方法，扩展了新的接口。此时子类不能完全替代父类，因为父类不能访问新添加的方法，这种关系称为”像是一个(is-like-a)“。</li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>通过继承，程序直到最后才能确定代码的地址。面向对象使用后期绑定的概念，当向对象发送信息时，被调用的代码直到运行时才确定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">    shape.erase();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">Triangle triangle = <span class="keyword">new</span> Triangle();</span><br><span class="line">Line line = <span class="keyword">new</span> Line();</span><br><span class="line">doSomething(circle);</span><br><span class="line">doSomething(triangle);</span><br><span class="line">doSomething(line);</span><br></pre></td></tr></table></figure>

<p>这种把子类当成其基类来处理的过程叫做“向上转型”（upcasting）。在面向对象的编程里，经常利用这种方法来给程序解耦。</p>
<p>发送消息给对象时，如果程序不知道接收的具体类型是什么，但最终执行是正确的，这就是对象的“多态性”（Polymorphism）。面向对象的程序设计语言是通过“动态绑定”的方式来实现对象的多态性的。</p>
<h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>Java 的单继承结构有很多好处。由于所有对象都具有一个公共接口，因此它们最终都属于同一个基类。</p>
<p>可以避免多继承中基类包含同名方法出错的问题。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>“集合”这种类型的对象可以存储任意类型、数量的其他对象。它能根据需要自动扩容，我们不用关心过程是如何实现的。</p>
<ol>
<li>集合可以提供不同类型的接口和外部行为。堆栈、队列的应用场景和集合、列表不同，它们中的一种提供的解决方案可能比其他灵活的多。</li>
<li>不同的集合某些操作有不同的效率。例如，List的两种基本类型：ArrayList和LinkedList。虽然两者具有相同的接口和外部行为，但是在某些<br>操作中它们的效率差别很大。在ArrayList中随机查找元素是很高效的，而LinkedList随机查找效率低下。反之，在LinkedList中插入元素的效率<br>要比在ArrayList中要高。由于底层数据结构的不同，每种集合类型在执行相同操作时会表现出效率上的差异。</li>
</ol>
<h2 id="对象创建和生命周期"><a href="#对象创建和生命周期" class="headerlink" title="对象创建和生命周期"></a>对象创建和生命周期</h2><p>Java使用动态内存分配。每次创建对象时，在堆内存中使用new关键字构建该对象的动态实例。在这种方式下，直到程序运行我们才能确定需要创建的<br>对象数量、生存时间和类型。什么时候需要，什么时候在堆内存中创建。因为内存的占用是动态管理的，所以在运行时，在堆内存开辟空间所需的时间<br>可能比在栈内存上要长(不一定)。在栈内存开辟和释放空间通常是一条将栈指针向下移动和一条将栈指针向上移动的汇编指令。开辟对内存空间的时间<br>取决于内存机制的设计。</p>
<p>Java的内存管理是建立在垃圾收集器上的，它能自动发现对象不再被使用并释放内存。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理机制将程序错误直接交给编程语言甚至是操作系统。”异常(Exception)“是一个从出错点”抛出”(thrown)后能被特定类型的异常处理程序捕<br>获(catch)的一个对象。他不会干扰程序的正常运行，仅当程序出错时才被执行。异常的发生是不会被忽略的，它终究会在某一时候被处理。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你看到的是对象的概念，这些概念是站在“问题空间”的(而不是站在计算机角度的“解决方案空间”)，以及发哦是那个消息给对象以指示该空间中的活动<br>。面向对象编程的一个优点是：设计良好的Java程序代码更容易被人阅读理解。由于Java类库的复用性，通常程序要写的代码也会少得多。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>On Java8读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收</title>
    <url>/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>垃圾回收是java针对堆中垃圾进行的清理，有效释放内存的一种手段。</p>
<h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h2><p>垃圾回收（Garbage Collection,GC)就是释放垃圾占用的空间，防止内存泄漏，可以有效使用内存，对内存堆中已经死亡或者长时间未使用的对象进行清除。</p>
<p>Java语言之前，C或者C++的程序创建对象需要不断开辟空间，当使用完成后需要释放，既要写构造函数，又要写析构函数，很多时候都在重复的 allocated，然后不停的析构。于是，有人就提出，能不能写一段程序实现这块功能，每次创建，释放控件的时候复用这段代码，而无需重复的书写呢？</p>
<p>1960年，基于 MIT 的 Lisp 首先提出了垃圾回收的概念，而这时 Java 还没有出世呢！所以实际上 GC 并不是Java的专利，GC 的历史远远大于 Java 的历史！</p>
<a id="more"></a>

<h2 id="怎么定义垃圾"><a href="#怎么定义垃圾" class="headerlink" title="怎么定义垃圾"></a>怎么定义垃圾</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用技术算法（Reachability Counting)是通过再对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用数加1，如果删除对该对象的引用，那么它的引用数就减1，当该对象的引用计数为0时，那么该对象就可以被回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String m = <span class="keyword">new</span> String(<span class="string">"jack"</span>);</span><br></pre></td></tr></table></figure>

<p>先创建一个字符串，这时候“jack”有一个引用，就是m。</p>
<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.png" alt></p>
<p>然后将m设置为null.这时候“jack”的引用次数就等于0了，在引用计数算法中，意味着这块内容就需要被回收了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.png" alt></p>
<p>引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了，而不是在进行垃圾搜集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束（不属于“Stop-The-World”）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountingGC</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ReferenceCountingGC a = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">"objA"</span>);</span><br><span class="line">    ReferenceCountingGC b = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">"objB"</span>);</span><br><span class="line"></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义两个对象</li>
<li>相互引用</li>
<li>置空各自的声明引用</li>
</ol>
<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.webp" alt></p>
<p>系统中不存在第三个对象引用a和b,所以a、b应该是系统回收的垃圾对象，但是因为垃圾对象之间的循环引用，引用计数器不为0，通过引用计数算法，也就永远无法通知GC收集器回收他们。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>可达性分析算法（Reachability Analysis）的基本思路是,通过一些被称为引用链(GC Roots)的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain）,当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。</p>
<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/4.jpg" alt></p>
<p>通过可达性算法，成功解决了引用计数无法解决的“循环依赖”问题，只要你无法与GC Root建立直接或间接的连接，系统就会判定你为可回收的对象。那这样就引申出了另一个问题，哪些属于 GC Root。</p>
<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>在java语言中，可作为GC Root的对象包括以下四种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/5.jpg" alt></p>
<h3 id="虚拟机栈（栈帧中的本地变量表）中引用的对象"><a href="#虚拟机栈（栈帧中的本地变量表）中引用的对象" class="headerlink" title="虚拟机栈（栈帧中的本地变量表）中引用的对象"></a>虚拟机栈（栈帧中的本地变量表）中引用的对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackLocalParameter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackLocalParameter</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StackLocalParameter s = <span class="keyword">new</span> StackLocalParameter(<span class="string">"localParameter"</span>);</span><br><span class="line">    s=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的s，即为GC Root,当s置空时，localParameter对象也断掉了与GC Root的引用链，将被回收。</p>
<h3 id="方法区中类静态属性引用的对象"><a href="#方法区中类静态属性引用的对象" class="headerlink" title="方法区中类静态属性引用的对象"></a>方法区中类静态属性引用的对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaStaicProperties</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodAreaStaicProperties m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAreaStaicProperties</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MethodAreaStaicProperties s = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"properties"</span>);</span><br><span class="line">    s.m = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"parameter"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>s为GC Root,s置为null,经过GC后，s所指的properties对象由于无法与GC Root建立关系被回收。<br>而m作为类的静态属性，也属于GC Root，parameter对象依然与GC Root建立着连接，所以此时parameter对象并不会被回收。</p>
<h3 id="方法区中常量引用的对象"><a href="#方法区中常量引用的对象" class="headerlink" title="方法区中常量引用的对象"></a>方法区中常量引用的对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">MethodAraaStaticProrperties</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodAraaStaticProrperties m = MethodAraaStaticProrperties(<span class="string">"final"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAraaStaticProrperties</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MethodAraaStaticProrperties s = <span class="keyword">new</span> MethodAraaStaticProrperties(<span class="string">"staticProperties"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m即为方法区中的常量引用，也为GC Root,s置为null后，final对象也不会因没有与GC Root建立联系而被回收。</p>
<h3 id="本地方法栈中引用的对象"><a href="#本地方法栈中引用的对象" class="headerlink" title="本地方法栈中引用的对象"></a>本地方法栈中引用的对象</h3><p>任何Native接口都会使用某种本地方法栈，实现的本地方法接口时使用C连接模型的话，那么它的本地方法栈就是C栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。<br>然而当它的调用是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的栈帧，虚拟机只是简单的连接并调用指定的本地方法。</p>
<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/6.jpg" alt></p>
<h2 id="垃圾回收算法与思想"><a href="#垃圾回收算法与思想" class="headerlink" title="垃圾回收算法与思想"></a>垃圾回收算法与思想</h2><h3 id="标记–清除算法（Mark-Sweep"><a href="#标记–清除算法（Mark-Sweep" class="headerlink" title="标记–清除算法（Mark-Sweep)"></a>标记–清除算法（Mark-Sweep)</h3><p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/7.webp" alt></p>
<p>标记清除算法是现代垃圾回收算法的思想基础。它分为标记阶段和清除阶段。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在<br>清除阶段，清除所有未被标记的对象。</p>
<p>上图中等方块的假设是 2M，小一些的是 1M，大一些的是 4M。等我们回收完，内存就会切成了很多段。我们知道开辟内存空间时，需要的是连续的内存区域，这时候我们需要一个 2M的内存区域，<br>其中有2个 1M 是没法用的。这样就导致，其实我们本身还有这么多的内存的，但却用不了。</p>
<h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h3><p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/8.jpg" alt></p>
<p>将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p>
<p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此，在真正需要垃圾回收的时候，复制算法的效率是很高的。又由于对象是在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保<br>回收后的内存空间是没有碎片的。虽然有以上两大优点，但是复制算法的缺点是将系统内存折半，代价太大。</p>
<h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/9.webp" alt></p>
<p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也会<br>较高。因此，基于老年代垃圾回收的特性，需要使用新的算法。</p>
<p>标记整理算法标记过程仍然与标记–清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象移动到内存的一端。之后，清理掉边界外所有的空间。这种方法既避免了碎片的产生，又规避了复制算法<br>只能利用一半内存的弊端。但是它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。</p>
<p><em>分代收集算法（Generational Collection）</em></p>
<p>分代收集算法严格来说并不是一种思想或理论，而是融合上述三种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和来年代，这样<br>就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、<br>没有额外空间对它进行分配担保，就必须使用标记-清理或者标记-整理算法来回收。</p>
<h2 id="内存模型与回收策略"><a href="#内存模型与回收策略" class="headerlink" title="内存模型与回收策略"></a>内存模型与回收策略</h2><p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/10.webp" alt></p>
<p>Java堆(Java Heap)是JVM所管理的内存中最大的一块，堆有事垃圾收集器管理的主要区域。</p>
<p>Java堆主要分为两个区域-年轻代与老年代，其中年轻代又分为Eden区和Survivor区，其中Survivor区又分From和To两个区。</p>
<h3 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h3><p>IBM 公司的专业研究表明，有将近98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。</p>
<p>通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。</p>
<h3 id="Survivor-区"><a href="#Survivor-区" class="headerlink" title="Survivor 区"></a>Survivor 区</h3><p>Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。</p>
<p><strong>为啥需要？</strong></p>
<p>不就是新生代到老年代么，直接 Eden 到 Old 不好了吗，为啥要这么复杂。想想如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。</p>
<p>所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</p>
<p><strong>为啥需要俩？</strong></p>
<p>设置两个 Survivor 区最大的好处就是解决内存碎片化。</p>
<p>我们先假设一下，Survivor 如果只有一个区域会怎样。Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。</p>
<p>这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。</p>
<h3 id="Old-区"><a href="#Old-区" class="headerlink" title="Old 区"></a>Old 区</h3><p>老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记 — 整理算法。</p>
<p>除了上述所说，在内存担保机制下，无法安置的对象会直接进到老年代，以下几种情况也会进入老年代。</p>
<p><strong>大对象</strong></p>
<p>大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。</p>
<p><strong>长期存活对象</strong></p>
<p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加1岁。当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置。</p>
<p><strong>动态对象年龄</strong></p>
<p>虚拟机并不重视要求对象年龄必须到15岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。</p>
<p>这其实有点类似于负载均衡，轮询是负载均衡的一种，保证每台机器都分得同样的请求。看似很均衡，但每台机的硬件不通，健康状况不同，我们还可以基于每台机接受的请求数，或每台机的响应时间等，来调整我们的负载均衡算法。</p>
<p>说明：本文内容来自率鸽的博客和《Java程序性能优化》，非原创，供自我学习使用。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装mysql数据库</title>
    <url>/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="Windows10安装Docker"><a href="#Windows10安装Docker" class="headerlink" title="Windows10安装Docker"></a>Windows10安装Docker</h2><p>1.打开Docker官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-0.png" alt></p>
<a id="more"></a>

<p>2.点击Get started按钮进入主页面</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-1.png" alt="upload successful"><br>3.点击会跳转到Docker账号注册页面</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-2.png" alt="upload successful"><br>4.注册登录成功后跳转到下载页面</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-3.png" alt="upload successful"><br>5.开启win10的Hyper-V ， 控制面板 -&gt; 程序 -&gt; 启用或关闭Windows功能 -&gt; 选中Hyper-V  ，之后重启。 然后点击下载的exe安装文件安装，一路确定就好了。</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-4.png" alt="upload successful"><br>6.启动docker， setting -&gt; Daemon 设置阿里云docker镜像仓库。<br>到<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">https://cr.console.aliyun.com/</a> 注册一个账户，登录进去后再列表选择加速器，把你的专属加速器地址复制粘贴到Registry mirrors中<br><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-6.png" alt="upload successful"></p>
<h2 id="Docker安装Mysql-8-0"><a href="#Docker安装Mysql-8-0" class="headerlink" title="Docker安装Mysql 8.0"></a>Docker安装Mysql 8.0</h2><p>1.打开Windows PowerShell;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
<p>2.运行镜像，设置root账号初始密码（admin），映射本地宿主机端口3310到Docker端口3306;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run  --name mysql8.0 -e MYSQL_ROOT_PASSWORD&#x3D;admin -p 3310:3306 -d mysql</span><br></pre></td></tr></table></figure>
<p>3.查看运行中的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-7.png" alt="upload successful"><br>4.进入mysql容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql8.0 bash</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-8.png" alt="upload successful"><br>5.登录mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>6.允许外部连接数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER user &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;admin&#39;;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>7.查看用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select host,user,plugin,authentication_string from mysql.user;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-9.png" alt="upload successful"><br>host为 % 表示不限制ip   localhost表示本机使用    plugin非mysql_native_password 则需要修改密码</p>
<p>8.使用DataGrip进行连接；</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-10.png" alt="upload successful"></p>
<h2 id="Docker-push镜像"><a href="#Docker-push镜像" class="headerlink" title="Docker push镜像"></a>Docker push镜像</h2><p>接下来把我们的mysql镜像推送到自己的docker hub的存储库中去。</p>
<p>1.访问网址：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> 在里面创建存储库</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-11.png" alt="upload successful"><br>2.把mysql镜像放入mysql存储库并标记为mysql8.0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag mysql creammangopie&#x2F;mysql:mysql8.0</span><br></pre></td></tr></table></figure>
<p>3.查看镜像</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-12.png" alt="upload successful"><br>4.推送镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker push creammangopie&#x2F;mysql:tagname</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-14.png" alt="upload successful"><br>5.Docker Hub上查看镜像</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-15.png" alt="upload successful"><br>6.从远程存储库中提取并运行镜像：现在当远程存储库有了镜像后，就可以从远程存储库提取并运行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -e MYSQL_ROOT_PASSWORD&#x3D;admin -p 3310:3306 creammangopie&#x2F;mysql:mysql8.0</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>springBoot(一)：创建springBoot项目</title>
    <url>/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="springBoot是什么"><a href="#springBoot是什么" class="headerlink" title="springBoot是什么"></a>springBoot是什么</h2><p>Spring Boot是构建所有基于Spring的应用程序的起点。Spring Boot旨在通过最少的Spring前期配置使您尽快启动并运行。</p>
<p>Spring Boot使创建可运行的独立，生产级基于Spring的应用程序变得容易。我们对Spring平台和第三方库持固执己见的观点，这样您就可以以最小的麻烦开始使用。大多数Spring Boot应用程序只需要很少的Spring配置。</p>
<a id="more"></a>

<p>您可以使用Spring Boot创建可以通过使用java -jar或更传统的战争部署启动的Java应用程序。我们还提供了一个运行“ spring脚本”的命令行工具。</p>
<p>我们的主要目标是：</p>
<p>为所有Spring开发提供根本上更快且可广泛访问的入门体验。</p>
<p>开箱即用，但由于需求开始与默认值有所出入，因此很快就会摆脱困境。</p>
<p>提供一系列大型项目通用的非功能性功能（例如嵌入式服务器，安全性，指标，运行状况检查和外部化配置）。</p>
<p>完全没有代码生成，也不需要XML配置。<br>(来自于spring官方文档)</p>
<h2 id="从spring官网构建一个项目"><a href="#从spring官网构建一个项目" class="headerlink" title="从spring官网构建一个项目"></a>从spring官网构建一个项目</h2><p><strong>Maven构建项目</strong></p>
<ul>
<li>1、访问<a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a></li>
<li>2、选择构建工具 Maven Project、Java、Spring Boot 版本 2.2.3 ：<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/1.png" alt></li>
<li>3、点击 Generate Project 下载项目压缩包</li>
<li>4、解压后，使用 Idea 导入项目，import -&gt; 选择解压后的文件夹 -&gt; OK，选择 Maven 一路 Next，OK done!</li>
</ul>
<p><strong>Idea 构建项目</strong></p>
<ul>
<li>1、选择 File -&gt; New —&gt; Project… </li>
<li>2、选择 Spring Initializr，Next 也会出现上述类似的配置界面，Idea 帮我们做了集成</li>
<li>3、填写相关内容后，点击 Next 选择依赖的包再点击 Next，最后确定信息无误点击 Finish。</li>
</ul>
<p>创建完成后就是以下这样子了：<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/2.png" alt></p>
<ul>
<li>src/main/java 程序开发以及主程序入口</li>
<li>src/main/resources 配置文件</li>
<li>src/test/java 测试代码</li>
</ul>
<p><strong>引入web</strong></p>
<p>1、pom.xml中添加支持web的模块：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>pom.xml 文件中默认有两个模块：</p>
<ul>
<li>spring-boot-starter ：核心模块，包括自动配置支持、日志和 YAML，如果引入了 spring-boot-starter-web web 模块可以去掉此配置，因为 spring-boot-starter-web 自动依赖了 spring-boot-starter。</li>
<li>spring-boot-starter-test ：测试模块，包括 JUnit、Hamcrest、Mockito。</li>
</ul>
<p>2、写一个controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HellowWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加了@RestController就不需要再写@ResponseBody了。</p>
<p>3、启动主程序，打开浏览器访问 <a href="http://localhost:8080/hello，就可以看到效果了。" target="_blank" rel="noopener">http://localhost:8080/hello，就可以看到效果了。</a></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>打开的src/test/下的测试入口，编写简单的 http 请求来测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mvc = MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> HellowWorldController()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">"/hello"</span>).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(equalTo(<span class="string">"Hello World"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在springBoot2.2.3中@SpringBootTest注解集成了@ExtendWith({SpringExtension.class})，<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/3.png" alt></p>
<p>在Junit4中要加@RunWith(SpringRunner.class)。</p>
<ul>
<li>status()，content()，equalTo在代码中没有找到引用，手动引入的：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.equalTo;</span><br></pre></td></tr></table></figure>
运行test结果如下：<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/4.png" alt></li>
</ul>
<h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>Junit5升级之后很多注解发生变化。</p>
<table>
<thead>
<tr>
<th align="center">JUnit4</th>
<th align="center">JUnit5</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@Test</td>
<td align="center">@Test</td>
<td align="left">表示该方法是一个测试方法。JUnit5与JUnit 4的@Test注解不同的是，它没有声明任何属性，因为JUnit Jupiter中的测试扩展是基于它们自己的专用注解来完成的。这样的方法会被继承，除非它们被覆盖</td>
</tr>
<tr>
<td align="center">@BeforeClass</td>
<td align="center">@BeforeAll</td>
<td align="left">表示使用了该注解的方法应该在当前类中所有使用了@Test @RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行；</td>
</tr>
<tr>
<td align="center">@AfterClass</td>
<td align="center">@AfterAll</td>
<td align="left">表示使用了该注解的方法应该在当前类中所有使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后执行；</td>
</tr>
<tr>
<td align="center">@Before</td>
<td align="center">@BeforeEach</td>
<td align="left">表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行</td>
</tr>
<tr>
<td align="center">@After</td>
<td align="center">@AfterEach</td>
<td align="left">表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后 执行</td>
</tr>
<tr>
<td align="center">@Ignore</td>
<td align="center">@Disabled</td>
<td align="left">用于禁用一个测试类或测试方法</td>
</tr>
<tr>
<td align="center">@Category</td>
<td align="center">@Tag</td>
<td align="left">用于声明过滤测试的tags，该注解可以用在方法或类上；类似于TesgNG的测试组或JUnit 4的分类。</td>
</tr>
<tr>
<td align="center">@Parameters</td>
<td align="center">@ParameterizedTest</td>
<td align="left">表示该方法是一个参数化测试</td>
</tr>
<tr>
<td align="center">@RunWith</td>
<td align="center">@ExtendWith</td>
<td align="left">@Runwith就是放在测试类名之前，用来确定这个类怎么运行的</td>
</tr>
<tr>
<td align="center">@Rule</td>
<td align="center">@ExtendWith</td>
<td align="left">Rule是一组实现了TestRule接口的共享类，提供了验证、监视TestCase和外部资源管理等能力</td>
</tr>
<tr>
<td align="center">@ClassRule</td>
<td align="center">@ExtendWith</td>
<td align="left">@ClassRule用于测试类中的静态变量，必须是TestRule接口的实例，且访问修饰符必须为public。</td>
</tr>
</tbody></table>
<h2 id="添加项目热启动"><a href="#添加项目热启动" class="headerlink" title="添加项目热启动"></a>添加项目热启动</h2><p>1、pom.xml添加以下配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>2、yml配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">devtools:</span><br><span class="line">  livereload:</span><br><span class="line">    enabled: true #是否支持livereload</span><br><span class="line">    port: <span class="number">35729</span></span><br><span class="line">  restart:</span><br><span class="line">    enabled: true #是否支持热部署</span><br></pre></td></tr></table></figure>
<p>3、开启idea自动make功能<br>settings:<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/5.png" alt></p>
<p>4、ctrl + shift + alt + /,选择Registry,勾上 Compiler autoMake allow when app running<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/6.png" alt></p>
<p>5、安装livereload插件</p>
<p>livereload 通过引入的脚本livereload.js在 livereload 服务和浏览器之间建立了一个 WebSocket 连接。每当监测到文件的变动，livereload 服务就会向浏览器发送一个信号，浏览器收到信号后就刷新页面，实现了实时刷新的效果。每次启动时，需要点击对应的图标。<br>下载livereload插件，将其安装到chrome扩展程序中。<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/7.png" alt></p>
<p>6、测试</p>
<ul>
<li>修改类 应用会重启</li>
<li>修改配置文件 应用会重启</li>
<li>修改静态文件（html、css等），应用不会重启，但是会调用livereload，浏览器会自动刷新，显示最新的修改内容。</li>
</ul>
]]></content>
      <categories>
        <category>springBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>热部署</tag>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的事务管理</title>
    <url>/2019/12/27/Mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h1><p>事务是逻辑上的一组操作，要求这一组操作要么同时完成 要么同时不完成。</p>
<h1 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h1><p>数据库默认就有事务，mysql中默认情况下一条语句独占一个事务。<br>也可以通过手动控制事务：</p>
<a id="more"></a>
<h2 id="sql控制事务："><a href="#sql控制事务：" class="headerlink" title="sql控制事务："></a>sql控制事务：</h2><p>start transaction; #开启一个事务 这条语句之后的所有的sql都将处在同一个事务中。这些sql都不会立即起作用 - 没有改变底层真正的数据。</p>
<p>commit; #提交事务 这个事务中所有的sql对数据库的影响立即发生 - 真正改变底层数据。</p>
<p>rollback; #回滚事务 撤销这个事务中所有的操作可能的对数据库的影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update account <span class="keyword">set</span> money = money-100 where name='a';</span><br><span class="line">update account <span class="keyword">set</span> money = money+100 where name='b';</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">start transaction;</span><br><span class="line">update account <span class="keyword">set</span> money = money-100 where name='a';</span><br><span class="line">update account <span class="keyword">set</span> money = money+100 where name='b';</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>
<h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">conn.setAutoCommit(false);#开启了事务，接下来在这个连接执行的所有sql都将处在同一个事务当中。</span><br><span class="line">			....</span><br><span class="line">conn.commit();#提交事务，将这个连接上执行的事务提交，对数据库产生影响。</span><br><span class="line">conn.rollback();#回滚事务，取消这个连接上执行的事务。</span><br><span class="line"></span><br><span class="line">SavePoint sp = conn.setSavePoint();</span><br><span class="line">conn.rollback(sp);</span><br></pre></td></tr></table></figure>
<p>要注意，回滚到回滚点时，回滚点之前的代码仍然是未提交也未回滚的状态，如果希望对数据库产生影响仍然需要进行提交的操作。</p>
<h1 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性  - ACID"></a>事务的四大特性  - ACID</h1><p>原子性 - 事务中的一组操作是不可分割的一个整体，要么一起成功，要么一起失败。</p>
<p>一致性 - 事务前后 无论事务是否成功 数据库应该都保持一个完整性的状态。数据库中数据是业务完整且约束完整的。</p>
<p>隔离性 - 多个并发事务之间应该互相隔离 互不影响</p>
<p>持久性 - 一个事务成功对数据库产生的影响是永久性的，无论发生什么情况 这种影响都不会被取消。</p>
<h1 id="隔离性的问题"><a href="#隔离性的问题" class="headerlink" title="隔离性的问题"></a>隔离性的问题</h1><p>加锁：同一时间内只能有一个人操作数据，可以完美的保证隔离性，但是这样一来数据库就相当于工作在单线程的状态下，同一时间只能有一个事务操作，并发的效率非常低下。</p>
<p>而现实生活中并不是所有的场景下都需要那么严格的事务隔离，在不同的业务场景下对隔离性的要求是不同的。</p>
<p>所以数据库的设计者在设计隔离性时并没有将隔离性写死，而是提供了不同的选项，数据库的使用者可以在使用数据时根据自身需求选择对应的选项来得到相应的隔离能力和性能。</p>
<p>通过这些选项，数据库使用者可以在数据库的隔离能力和性能间做一个权衡，从而在保证需要的隔离性的基础上得到尽量好的性能。</p>
<h1 id="四大隔离级别"><a href="#四大隔离级别" class="headerlink" title="四大隔离级别"></a>四大隔离级别</h1><p>Read uncommitted<br>Read committed<br>Repeatable read<br>Serializable  </p>
<p>(1)Read uncoommitted<br>    数据库不保证任何事务特性 可能出现脏读 不可重复读 虚读(幻读) 问题<br>    <strong>脏读</strong>:一个事务读取到了另一个事务未提交的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">	<span class="keyword">set</span> session transaction isolation level read uncoommitted;</span><br><span class="line">---------------</span><br><span class="line">	a: 1000</span><br><span class="line">	b: 1000</span><br><span class="line">---------------</span><br><span class="line">b:</span><br><span class="line">	start transaction;</span><br><span class="line">	update account <span class="keyword">set</span> money = money - 100 where name = 'b';</span><br><span class="line">	update account <span class="keyword">set</span> money = money + 100 where name = 'a';</span><br><span class="line"></span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	select * from account;</span><br><span class="line">---------------</span><br><span class="line">	a: 1100</span><br><span class="line">	b: 900</span><br><span class="line">---------------</span><br><span class="line">	commit;</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">	rollback;</span><br><span class="line"></span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	select * from account;</span><br><span class="line">---------------</span><br><span class="line">	a: 1000</span><br><span class="line">	b: 1000</span><br><span class="line">---------------</span><br><span class="line">	commit;</span><br></pre></td></tr></table></figure>
<p>(2)Read committed<br>保证部分隔离 可以防止脏读问题 但是具有不可重复读 和 虚读(幻读)问题<br><strong>不可重复读</strong>：一个事务读取到另一个事务已经提交的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">	<span class="keyword">set</span> session transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 1000 1000</span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">	start transaction;</span><br><span class="line">	select 活期 from account where name = 'a'; -- 活期存款1000</span><br><span class="line">	select 定期 from account where name = 'a'; -- 定期存款1000</span><br><span class="line">	select 固定 from account where name = 'a'; -- 固定存款1000</span><br><span class="line">-------------------------</span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	update account <span class="keyword">set</span> money = money - 1000 where name = 'a';</span><br><span class="line">	commit;</span><br><span class="line">-------------------------</span><br><span class="line">b:</span><br><span class="line">    select 活期 + 定期 + 固定 from account where name = 'a';</span><br><span class="line">-------------------------</span><br><span class="line">    总资产2000</span><br></pre></td></tr></table></figure>

<p>(3)Repeatable read<br>保证部分隔离 可以防止脏读 不可重复读问题 但是具有虚读(幻读)问题<br><strong>虚读(幻读)</strong>：一个事务读取全表数据时 读取到另一个事务向表中新增、删除操作提交的结果<br>**虚读(幻读)问题 有可能出现 有可能不出现 概率非常低</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation level Repeatable read;</span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 </span><br><span class="line">	b 1000</span><br><span class="line">-------------------------</span><br><span class="line">c：</span><br><span class="line">	start transaction;</span><br><span class="line">	select count(*) from account; -- 2人</span><br><span class="line">	select sum(money) from account; -- 2000元</span><br><span class="line">--------</span><br><span class="line">d：</span><br><span class="line">	start transaction;</span><br><span class="line">	insert into account values(d 4000);</span><br><span class="line">	commit;</span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 </span><br><span class="line">	b 1000</span><br><span class="line">	d 4000</span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line">select avg(money) from account; -- 2000元</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>(4)Serializable<br>保证完全隔离 可以防止脏读 不可重复读 虚读(幻读)问题<br>本质上是靠锁来实现的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">从安全性说：</span><br><span class="line">	Serializable &gt; Repeatable read &gt; Read committed &gt; Read uncommitted </span><br><span class="line">从效率说：</span><br><span class="line">	Read uncommitted &gt;Read committed &gt; Repeatable read &gt; Serializable</span><br></pre></td></tr></table></figure>
<p>真正在开发的过程中应该根据自身的业务需求选择一个在<strong>能防止想要防止的隔离性问题的级别</strong>中<strong>性能</strong>最好的一个隔离级别<br>mysql的<strong>默认</strong>隔离级别时 <strong>Repeatable read</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">查看数据库隔离级别：</span><br><span class="line">	select @@tx_isolation;</span><br><span class="line">设置数据库的隔离级别:</span><br><span class="line">	<span class="keyword">set</span> [session/global] transaction isolation level xxxxxx;</span><br></pre></td></tr></table></figure>

<h1 id="数据库中的锁机制"><a href="#数据库中的锁机制" class="headerlink" title="数据库中的锁机制"></a>数据库中的锁机制</h1><p>数据库中是有锁的，但是锁如果控制不好，对效率影响非常大，所以数据库设计者对锁做了特别的设计：  </p>
<table>
<thead>
<tr>
<th align="center">业务情况</th>
<th align="center">是否互斥</th>
</tr>
</thead>
<tbody><tr>
<td align="center">两个查询</td>
<td align="center">没有必要互斥</td>
</tr>
<tr>
<td align="center">两个修改</td>
<td align="center">必须互斥</td>
</tr>
<tr>
<td align="center">一个查询 另一个修改</td>
<td align="center">具体看情况 Serializable隔离级别下需要排斥 其他隔离级别不需要</td>
</tr>
</tbody></table>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁和共享锁可以共存，共享锁和排他锁不能共存<br>在非Serializable级别中查询不加任何锁 在Seralizable级别中查询加共享锁</p>
<h2 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h2><p> 排他锁和任何锁都不能共存<br> 在任意隔离级别下做增删改都加排他锁</p>
<p><strong>操作和锁的关系</strong><br>            1. 非Serializable级别,查询不加任何锁<br>            2. Serializable级别,查询加共享锁<br>            3. 任意隔离级别下,增删改都加排他锁</p>
<table>
<thead>
<tr>
<th>a(Rep)</th>
<th>b(Rep)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>都不加锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>不互斥</td>
<td>a不加锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>不互斥</td>
<td>a排他锁+b不加锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a(Ser)</th>
<th>b(Rep)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>a共享锁+b不加锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>互斥</td>
<td>a共享锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>不互斥</td>
<td>a排他锁+b不加锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a(Ser)</th>
<th>b(Ser)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>a共享锁+b共享锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>互斥</td>
<td>a共享锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>互斥</td>
<td>a排他锁+b共享锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<p>死锁：<br>    当两边都时Serializable隔离级别时<br>    两边都先进行查询 再尝试进行修改 则互相等待对方释放共享锁 都无法接着执行 造成了死锁<br>死锁的解决有两种办法：避免死锁 解决死锁<br>    mysql没有避免死锁，尝试检测死锁，发现死锁后，退出一方，执行另一方来解决了死锁。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>default关键字</title>
    <url>/2019/12/27/default%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>default关键字在Java中主要有两个用法，一个是在switch中执行，另一个是jdk1.8之后使用default关键字在接口中定义普通方法。</p>
<h1 id="default在Switch中的使用"><a href="#default在Switch中的使用" class="headerlink" title="default在Switch中的使用"></a>default在Switch中的使用</h1><p>default会在case匹配失败后执行</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ch = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是0"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是1"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是2"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              System.out.println(<span class="string">"默认值"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：<code>default</code><br>注：若case中没有break，则匹配成功后会继续执行代码，直到碰到break或return或者switch语句结束为止，这种情况下default可能会执行。</p>
<h1 id="default在接口中的使用（jdk1-8之后）"><a href="#default在接口中的使用（jdk1-8之后）" class="headerlink" title="default在接口中的使用（jdk1.8之后）"></a>default在接口中的使用（jdk1.8之后）</h1><p>在jdk1.8之后，接口中可以使用default定义普通方法。这样如果某些方法对于所有的子类都具有同样的实现，那么可以减少定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        是一个普通方法，jdk1.8之后才有</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">"我是接口1的普通方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMss</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是接口1的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        IMessage1 iMessage = <span class="keyword">new</span> MessageImpl1();</span><br><span class="line">        iMessage.print();</span><br><span class="line">        iMessage.getMsg();</span><br><span class="line">        IMessage1.getMss();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><code>MessageImpl1
我是接口1的普通方法
我是接口1的静态方法</code></p>
<h2 id="两个接口中默认方法冲突问题"><a href="#两个接口中默认方法冲突问题" class="headerlink" title="两个接口中默认方法冲突问题"></a>两个接口中默认方法冲突问题</h2><p>当一个类实现了两个接口，而两个接口中都有相同的默认方法，此时会出现什么情况呢？<br>我们再来定义一个新的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是接口2的普通方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让一个类同时实现接口1和接口2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl</span> <span class="keyword">implements</span> <span class="title">IMessage1</span> , <span class="title">IMessage2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器会报错<br><img src="https://img-blog.csdnimg.cn/20190804143036881.png" alt="IDEA中方法冲突提示"><br>此时编译器不知道应该从哪个接口中去调用默认方法，所以报错。<br>解决方法：<code>在实现类中重写该方法</code></p>
<h2 id="类与接口中定义了相同的方法"><a href="#类与接口中定义了相同的方法" class="headerlink" title="类与接口中定义了相同的方法"></a>类与接口中定义了相同的方法</h2><p>实现类1实现接口1并重写getMsg()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm from MessageImpl1 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类2继承实现类1并实现接口2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl2</span> <span class="keyword">extends</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若此时在实现类2中调用getMsg()方法，是执行MessageImpl1中的方法还是IMessage2中的呢？<br>执行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MessageImpl2 messageImpl2 = <span class="keyword">new</span> MessageImpl2();</span><br><span class="line">        messageImpl2.getMsg();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<code>I&#39;m from MessageImpl1</code><br>答：<strong>类优先级高于接口</strong>，所以执行实现类1中的方法。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>-java语法</tag>
      </tags>
  </entry>
</search>
