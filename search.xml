<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>springBoot(一)：创建springBoot项目</title>
    <url>/2019/12/30/springBoot1/</url>
    <content><![CDATA[<p>#springBoot是什么<br>Spring Boot是构建所有基于Spring的应用程序的起点。Spring Boot旨在通过最少的Spring前期配置使您尽快启动并运行。<br><img src="/2019/12/30/springBoot1/1.png" alt></p>
]]></content>
      <categories>
        <category>springBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>热部署</tag>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的事务管理</title>
    <url>/2019/12/27/Mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h1><p>事务是逻辑上的一组操作，要求这一组操作要么同时完成 要么同时不完成。</p>
<h1 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h1><p>数据库默认就有事务，mysql中默认情况下一条语句独占一个事务。<br>也可以通过手动控制事务：</p>
<a id="more"></a>
<h2 id="sql控制事务："><a href="#sql控制事务：" class="headerlink" title="sql控制事务："></a>sql控制事务：</h2><p>start transaction; #开启一个事务 这条语句之后的所有的sql都将处在同一个事务中。这些sql都不会立即起作用 - 没有改变底层真正的数据。</p>
<p>commit; #提交事务 这个事务中所有的sql对数据库的影响立即发生 - 真正改变底层数据。</p>
<p>rollback; #回滚事务 撤销这个事务中所有的操作可能的对数据库的影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update account <span class="keyword">set</span> money = money-100 where name='a';</span><br><span class="line">update account <span class="keyword">set</span> money = money+100 where name='b';</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">start transaction;</span><br><span class="line">update account <span class="keyword">set</span> money = money-100 where name='a';</span><br><span class="line">update account <span class="keyword">set</span> money = money+100 where name='b';</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>
<h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">conn.setAutoCommit(false);#开启了事务，接下来在这个连接执行的所有sql都将处在同一个事务当中。</span><br><span class="line">			....</span><br><span class="line">conn.commit();#提交事务，将这个连接上执行的事务提交，对数据库产生影响。</span><br><span class="line">conn.rollback();#回滚事务，取消这个连接上执行的事务。</span><br><span class="line"></span><br><span class="line">SavePoint sp = conn.setSavePoint();</span><br><span class="line">conn.rollback(sp);</span><br></pre></td></tr></table></figure>
<p>要注意，回滚到回滚点时，回滚点之前的代码仍然是未提交也未回滚的状态，如果希望对数据库产生影响仍然需要进行提交的操作。</p>
<h1 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性  - ACID"></a>事务的四大特性  - ACID</h1><p>原子性 - 事务中的一组操作是不可分割的一个整体，要么一起成功，要么一起失败。</p>
<p>一致性 - 事务前后 无论事务是否成功 数据库应该都保持一个完整性的状态。数据库中数据是业务完整且约束完整的。</p>
<p>隔离性 - 多个并发事务之间应该互相隔离 互不影响</p>
<p>持久性 - 一个事务成功对数据库产生的影响是永久性的，无论发生什么情况 这种影响都不会被取消。</p>
<h1 id="隔离性的问题"><a href="#隔离性的问题" class="headerlink" title="隔离性的问题"></a>隔离性的问题</h1><p>加锁：同一时间内只能有一个人操作数据，可以完美的保证隔离性，但是这样一来数据库就相当于工作在单线程的状态下，同一时间只能有一个事务操作，并发的效率非常低下。</p>
<p>而现实生活中并不是所有的场景下都需要那么严格的事务隔离，在不同的业务场景下对隔离性的要求是不同的。</p>
<p>所以数据库的设计者在设计隔离性时并没有将隔离性写死，而是提供了不同的选项，数据库的使用者可以在使用数据时根据自身需求选择对应的选项来得到相应的隔离能力和性能。</p>
<p>通过这些选项，数据库使用者可以在数据库的隔离能力和性能间做一个权衡，从而在保证需要的隔离性的基础上得到尽量好的性能。</p>
<h1 id="四大隔离级别"><a href="#四大隔离级别" class="headerlink" title="四大隔离级别"></a>四大隔离级别</h1><p>Read uncommitted<br>Read committed<br>Repeatable read<br>Serializable  </p>
<p>(1)Read uncoommitted<br>    数据库不保证任何事务特性 可能出现脏读 不可重复读 虚读(幻读) 问题<br>    <strong>脏读</strong>:一个事务读取到了另一个事务未提交的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">	<span class="keyword">set</span> session transaction isolation level read uncoommitted;</span><br><span class="line">---------------</span><br><span class="line">	a: 1000</span><br><span class="line">	b: 1000</span><br><span class="line">---------------</span><br><span class="line">b:</span><br><span class="line">	start transaction;</span><br><span class="line">	update account <span class="keyword">set</span> money = money - 100 where name = 'b';</span><br><span class="line">	update account <span class="keyword">set</span> money = money + 100 where name = 'a';</span><br><span class="line"></span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	select * from account;</span><br><span class="line">---------------</span><br><span class="line">	a: 1100</span><br><span class="line">	b: 900</span><br><span class="line">---------------</span><br><span class="line">	commit;</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">	rollback;</span><br><span class="line"></span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	select * from account;</span><br><span class="line">---------------</span><br><span class="line">	a: 1000</span><br><span class="line">	b: 1000</span><br><span class="line">---------------</span><br><span class="line">	commit;</span><br></pre></td></tr></table></figure>
<p>(2)Read committed<br>保证部分隔离 可以防止脏读问题 但是具有不可重复读 和 虚读(幻读)问题<br><strong>不可重复读</strong>：一个事务读取到另一个事务已经提交的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">	<span class="keyword">set</span> session transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 1000 1000</span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">	start transaction;</span><br><span class="line">	select 活期 from account where name = 'a'; -- 活期存款1000</span><br><span class="line">	select 定期 from account where name = 'a'; -- 定期存款1000</span><br><span class="line">	select 固定 from account where name = 'a'; -- 固定存款1000</span><br><span class="line">-------------------------</span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	update account <span class="keyword">set</span> money = money - 1000 where name = 'a';</span><br><span class="line">	commit;</span><br><span class="line">-------------------------</span><br><span class="line">b:</span><br><span class="line">    select 活期 + 定期 + 固定 from account where name = 'a';</span><br><span class="line">-------------------------</span><br><span class="line">    总资产2000</span><br></pre></td></tr></table></figure>

<p>(3)Repeatable read<br>保证部分隔离 可以防止脏读 不可重复读问题 但是具有虚读(幻读)问题<br><strong>虚读(幻读)</strong>：一个事务读取全表数据时 读取到另一个事务向表中新增、删除操作提交的结果<br>**虚读(幻读)问题 有可能出现 有可能不出现 概率非常低</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation level Repeatable read;</span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 </span><br><span class="line">	b 1000</span><br><span class="line">-------------------------</span><br><span class="line">c：</span><br><span class="line">	start transaction;</span><br><span class="line">	select count(*) from account; -- 2人</span><br><span class="line">	select sum(money) from account; -- 2000元</span><br><span class="line">--------</span><br><span class="line">d：</span><br><span class="line">	start transaction;</span><br><span class="line">	insert into account values(d 4000);</span><br><span class="line">	commit;</span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 </span><br><span class="line">	b 1000</span><br><span class="line">	d 4000</span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line">select avg(money) from account; -- 2000元</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>(4)Serializable<br>保证完全隔离 可以防止脏读 不可重复读 虚读(幻读)问题<br>本质上是靠锁来实现的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">从安全性说：</span><br><span class="line">	Serializable &gt; Repeatable read &gt; Read committed &gt; Read uncommitted </span><br><span class="line">从效率说：</span><br><span class="line">	Read uncommitted &gt;Read committed &gt; Repeatable read &gt; Serializable</span><br></pre></td></tr></table></figure>
<p>真正在开发的过程中应该根据自身的业务需求选择一个在<strong>能防止想要防止的隔离性问题的级别</strong>中<strong>性能</strong>最好的一个隔离级别<br>mysql的<strong>默认</strong>隔离级别时 <strong>Repeatable read</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">查看数据库隔离级别：</span><br><span class="line">	select @@tx_isolation;</span><br><span class="line">设置数据库的隔离级别:</span><br><span class="line">	<span class="keyword">set</span> [session/global] transaction isolation level xxxxxx;</span><br></pre></td></tr></table></figure>

<h1 id="数据库中的锁机制"><a href="#数据库中的锁机制" class="headerlink" title="数据库中的锁机制"></a>数据库中的锁机制</h1><p>数据库中是有锁的，但是锁如果控制不好，对效率影响非常大，所以数据库设计者对锁做了特别的设计：  </p>
<table>
<thead>
<tr>
<th align="center">业务情况</th>
<th align="center">是否互斥</th>
</tr>
</thead>
<tbody><tr>
<td align="center">两个查询</td>
<td align="center">没有必要互斥</td>
</tr>
<tr>
<td align="center">两个修改</td>
<td align="center">必须互斥</td>
</tr>
<tr>
<td align="center">一个查询 另一个修改</td>
<td align="center">具体看情况 Serializable隔离级别下需要排斥 其他隔离级别不需要</td>
</tr>
</tbody></table>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁和共享锁可以共存，共享锁和排他锁不能共存<br>在非Serializable级别中查询不加任何锁 在Seralizable级别中查询加共享锁</p>
<h2 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h2><p> 排他锁和任何锁都不能共存<br> 在任意隔离级别下做增删改都加排他锁</p>
<p><strong>操作和锁的关系</strong><br>            1. 非Serializable级别,查询不加任何锁<br>            2. Serializable级别,查询加共享锁<br>            3. 任意隔离级别下,增删改都加排他锁</p>
<table>
<thead>
<tr>
<th>a(Rep)</th>
<th>b(Rep)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>都不加锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>不互斥</td>
<td>a不加锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>不互斥</td>
<td>a排他锁+b不加锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a(Ser)</th>
<th>b(Rep)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>a共享锁+b不加锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>互斥</td>
<td>a共享锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>不互斥</td>
<td>a排他锁+b不加锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a(Ser)</th>
<th>b(Ser)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>a共享锁+b共享锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>互斥</td>
<td>a共享锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>互斥</td>
<td>a排他锁+b共享锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<p>死锁：<br>    当两边都时Serializable隔离级别时<br>    两边都先进行查询 再尝试进行修改 则互相等待对方释放共享锁 都无法接着执行 造成了死锁<br>死锁的解决有两种办法：避免死锁 解决死锁<br>    mysql没有避免死锁，尝试检测死锁，发现死锁后，退出一方，执行另一方来解决了死锁。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>default关键字</title>
    <url>/2019/12/27/default%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>default关键字在Java中主要有两个用法，一个是在switch中执行，另一个是jdk1.8之后使用default关键字在接口中定义普通方法。</p>
<h1 id="default在Switch中的使用"><a href="#default在Switch中的使用" class="headerlink" title="default在Switch中的使用"></a>default在Switch中的使用</h1><p>default会在case匹配失败后执行</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ch = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是0"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是1"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是2"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              System.out.println(<span class="string">"默认值"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：<code>default</code><br>注：若case中没有break，则匹配成功后会继续执行代码，直到碰到break或return或者switch语句结束为止，这种情况下default可能会执行。</p>
<h1 id="default在接口中的使用（jdk1-8之后）"><a href="#default在接口中的使用（jdk1-8之后）" class="headerlink" title="default在接口中的使用（jdk1.8之后）"></a>default在接口中的使用（jdk1.8之后）</h1><p>在jdk1.8之后，接口中可以使用default定义普通方法。这样如果某些方法对于所有的子类都具有同样的实现，那么可以减少定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        是一个普通方法，jdk1.8之后才有</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">"我是接口1的普通方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMss</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是接口1的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        IMessage1 iMessage = <span class="keyword">new</span> MessageImpl1();</span><br><span class="line">        iMessage.print();</span><br><span class="line">        iMessage.getMsg();</span><br><span class="line">        IMessage1.getMss();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><code>MessageImpl1
我是接口1的普通方法
我是接口1的静态方法</code></p>
<h2 id="两个接口中默认方法冲突问题"><a href="#两个接口中默认方法冲突问题" class="headerlink" title="两个接口中默认方法冲突问题"></a>两个接口中默认方法冲突问题</h2><p>当一个类实现了两个接口，而两个接口中都有相同的默认方法，此时会出现什么情况呢？<br>我们再来定义一个新的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是接口2的普通方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让一个类同时实现接口1和接口2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl</span> <span class="keyword">implements</span> <span class="title">IMessage1</span> , <span class="title">IMessage2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器会报错<br><img src="https://img-blog.csdnimg.cn/20190804143036881.png" alt="IDEA中方法冲突提示"><br>此时编译器不知道应该从哪个接口中去调用默认方法，所以报错。<br>解决方法：<code>在实现类中重写该方法</code></p>
<h2 id="类与接口中定义了相同的方法"><a href="#类与接口中定义了相同的方法" class="headerlink" title="类与接口中定义了相同的方法"></a>类与接口中定义了相同的方法</h2><p>实现类1实现接口1并重写getMsg()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm from MessageImpl1 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类2继承实现类1并实现接口2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl2</span> <span class="keyword">extends</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若此时在实现类2中调用getMsg()方法，是执行MessageImpl1中的方法还是IMessage2中的呢？<br>执行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MessageImpl2 messageImpl2 = <span class="keyword">new</span> MessageImpl2();</span><br><span class="line">        messageImpl2.getMsg();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<code>I&#39;m from MessageImpl1</code><br>答：<strong>类优先级高于接口</strong>，所以执行实现类1中的方法。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>-java语法</tag>
      </tags>
  </entry>
</search>
