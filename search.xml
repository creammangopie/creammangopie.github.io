<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《On-Java8》2-万物皆对象</title>
    <url>/2020/04/22/%E3%80%8AOn-Java8%E3%80%8B2-%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="对象操纵"><a href="#对象操纵" class="headerlink" title="对象操纵"></a>对象操纵</h2><p>Java利用万物皆对象的思想和单一一致的语法方式来简化问题。虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的引用。</p>
<a id="more"></a>

<p>创建引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s;</span><br></pre></td></tr></table></figure>

<p>创建引用同时进行初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"jerry"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>“引用”用来关联“对象”。在Java中，通常我们使用new操作符来创建一个新对象。new关键字表示：创建一个新的对象实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"jerry"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><ol>
<li>寄存器(Registers) 最快的存储区域，位于CPU内部。寄存器数量十分有限，按照需求进行分配。我们没有直接的控制前，也无法在自己<br>的程序里找到寄存器存在的踪迹。</li>
<li>栈内存(Stack) 存在于常规内存RAM(随机访问存储器，Random Access Memory)区域中，可通过栈指针获得处理器的直接支持。栈指针<br>下移分配内存，上移释放内存，这是一种快速有效的内存分配方法，速度仅次于寄存器。创建程序时，Java系统必须准确的直到栈内保存的所<br>有项的生命周期。这种约束限制了系统的灵活性。因此，栈内存一般存放对象的引用，对象是保存在堆内存中的。</li>
<li>堆内存(Heap) 这是一种通用的内存池(也在RAM区域)，所有Java对象都存在其中。</li>
<li>常量存储(Constant storage) 常量值通常直接放在程序代码中，因为它们永远不会改变，如需严格保护，可以存放在ROM(只读存储器，<br>Read Only Memory)中。</li>
<li>非RAM存储(Non-RAM storage) 数据完全存在于程序之外，在程序未运行及脱离程序控制后依然存在。</li>
</ol>
<ul>
<li>序列化对象：对象被转换为字节流，通常被发送到另一台机器；</li>
<li>持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。</li>
</ul>
<p>这些存储的方式都是将对象的转存于另一个介质中，并在需要时恢复成常规的、基于RAM的对象。</p>
<h3 id="基本类型的存储"><a href="#基本类型的存储" class="headerlink" title="基本类型的存储"></a>基本类型的存储</h3><p>Java的基本类型被存放在栈内存中。</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">大小</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
<th align="center">包装类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16 bits</td>
<td align="center">Unicode 0</td>
<td align="center">Unicode $2^{16}$ -1</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">8 bits</td>
<td align="center">-128</td>
<td align="center">+127</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16 bits</td>
<td align="center">-$2^{15}$</td>
<td align="center">+$2^{15}$-1</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32 bits</td>
<td align="center">-$2^{31}$</td>
<td align="center">+$2^{31}$-1</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64 bits</td>
<td align="center">-$2^{63}$</td>
<td align="center">+$2^{63}$-1</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32 bits</td>
<td align="center">IEEE754</td>
<td align="center">IEEE754</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64 bits</td>
<td align="center">IEEE754</td>
<td align="center">IEEE754</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Void</td>
</tr>
</tbody></table>
<p>基本类型有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类。</p>
<h3 id="高精度数值"><a href="#高精度数值" class="headerlink" title="高精度数值"></a>高精度数值</h3><p>BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。 BigDecimal 支持任意精度的定<br>点数字。例如，可用它进行精确的货币计算。</p>
<h3 id="数组的存储"><a href="#数组的存储" class="headerlink" title="数组的存储"></a>数组的存储</h3><p>在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下<br>标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。</p>
<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是</span></span><br><span class="line"><span class="comment">* 跨越多行的</span></span><br><span class="line"><span class="comment">* 注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是跨越多</span></span><br><span class="line"><span class="comment">行的注释 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这是单行注释</span><br></pre></td></tr></table></figure>

<h2 id="对象清理"><a href="#对象清理" class="headerlink" title="对象清理"></a>对象清理</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在 Java 中，你不能执行以下操作，即使这在 C 和 C++ 中是合法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">96</span>; <span class="comment">// Illegal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中， Java 编译器会在提示变量 x 已经被定义过了。</p>
<h3 id="对象作用域"><a href="#对象作用域" class="headerlink" title="对象作用域"></a>对象作用域</h3><p>Java 对象与基本类型具有不同的生命周期。当我们使用 new 关键字来创建 Java 对象时，它的生命周期将会超出作用域。<br>new出来的对象会一直存在，直到Java垃圾收集器检查并清除。</p>
<h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><h3 id="基本类型默认值"><a href="#基本类型默认值" class="headerlink" title="基本类型默认值"></a>基本类型默认值</h3><h3 id="方法使用"><a href="#方法使用" class="headerlink" title="方法使用"></a>方法使用</h3><p>在 Java 中，方法决定对象能接收哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[返回类型] [方法名](<span class="comment">/*参数列表*/</span>)&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><p>方法的返回类型表明了当你调用它时会返回的结果类型。参数列表则显示了可被传递到方法内部的参数类型及名称。方法名和参数列表统称<br>为方法签名（signature of the method）。签名作为方法的唯一标识。</p>
<h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><p>方法参数列表指定了传递给方法的信息。</p>
<h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><h3 id="命名可见性"><a href="#命名可见性" class="headerlink" title="命名可见性"></a>命名可见性</h3><p>为一个类库生成一个明确的名称，Java 创建者希望我们反向使用自己的网络域名，因为域名通常是唯一的。</p>
<h3 id="使用其它组件"><a href="#使用其它组件" class="headerlink" title="使用其它组件"></a>使用其它组件</h3><p>你必须通过使用 import 关键字来告诉 Java 编译器具体要使用的类。</p>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>类是对象的外观及行为方式的描述。通常只有在使用 new 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这<br>种方式在两种情况下是不足的。</p>
<ol>
<li>有时你只想为特定字段（注：也称为属性、域）分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。</li>
<li>创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。</li>
</ol>
<p>static 关键字（从 C++ 采用）就符合上述两点要求。当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例<br> 。 即使我们从未创建过该类的对象，也可以调用其静态方法或访问其静态字段。</p>
<h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><p>ava 编程语言编码规范（Code Conventions for the Java Programming Language）要求类名的首字母大写。 如果类名是由多个<br>单词构成的，则每个单词的首字母都应大写（不采用下划线来分隔）。</p>
<p>有时称这种命名风格叫“驼峰命名法”。对于几乎所有其他方法，字段（成员变量）和对象引用名都采用驼峰命名的方式，但是它们的首字母<br>不需要大写。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>On Java8读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《On Java8》1-对象的概念</title>
    <url>/2020/04/08/%E3%80%8AOn-Java8%E3%80%8B1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>面向对象编程(Object-Oriented Programming OOP)是一种编程思维方式和编码架构。</p>
<a id="more"></a>

<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>我们将问题空间中的元素以及它们在解决方案空间的表示称作“对象”(<strong>Object</strong>)。这与现实世界的“对象”和“物体”相似，它们都有自己的特征和行为。</p>
<ol>
<li>万物皆对象</li>
<li>程序是一组对象，通过消息传递来告诉彼此该做什么</li>
<li>每个对象都有自己的存储空间，可容纳其它对象</li>
<li>每个对象都有一种类型</li>
<li>同一类所有对象都能接收相同的消息</li>
</ol>
<p>一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态),方法(产生行为),并彼此区分(每个对象在内存中都有唯一的地址).</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>如何在“问题空间”（问题实际存在的地方）的元素与“方案空间”（对实际问题进行建模的地方，如计算机）的元素之间建立理想的“一对一”的映射关系。</p>
<p>我们向对象发出的请求是通过它的“接口”定义的，对象的“类型”或“类”则规定了它的接口形式。</p>
<p><img src="/2020/04/08/%E3%80%8AOn-Java8%E3%80%8B1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/1.png" alt></p>
<p>上图遵循 UML（Unified Modeling Language，统一建模语言）的格式。每个类由一个框表示，框的顶部有类型名称，框中间部分是要描述的任何数据成员，方法（属于此对象的方法，它们接收任何发送到该对象的消息）在框的底部。通常，只有类的名称和公共方法在 UML 设计图中显示，因此中间部分未显示，如本例所示。如果你只对类名感兴趣，则也不需要显示方法信息。</p>
<h2 id="服务提供"><a href="#服务提供" class="headerlink" title="服务提供"></a>服务提供</h2><p>在开发或理解程序设计时，我们可以将对象看成是“服务提供者”。</p>
<p>软件设计的基本原则是高内聚：每个组件的内部作用明确，功能又紧密相关。在良好的面向对象设计中，每个对象功能单一且高效，这样的程序设计可以提高我们代码的复用性。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ol>
<li><p><strong>public</strong>（公开）表示任何人都可以访问和使用该元素；</p>
</li>
<li><p><strong>private</strong>（私有）除了类本身和类内部的方法，外界无法直接访问该元素。private 是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误；</p>
</li>
<li><p><strong>protected</strong>（受保护）类似于 private，区别是子类（下一节就会引入继承的概念）可以访问 protected 的成员，但不能访问 private 成员；</p>
</li>
<li><p><strong>default</strong>（默认）如果你不使用前面的三者，默认就是 default 访问权限。default 被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。</p>
</li>
</ol>
<h2 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h2><ul>
<li>组合（Composition）经常用来表示“拥有”关系（has-a relationship）。例如，“汽车拥有引擎”。</li>
<li>聚合（Aggregation）动态的组合。</li>
</ul>
<p><img src="/2020/04/08/%E3%80%8AOn-Java8%E3%80%8B1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/2.png" alt></p>
<p>上图中实心三角形指向“ Car ”表示 组合 的关系；如果是 聚合 关系，可以使用空心三角形。</p>
<p>聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件。这个区别可以用来区分某个关联关系到底是组合还是聚合。两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类。但我们若能利用现成的数据类型，对其进行“克隆”，再根据情况进行添加和修改，情况就显得理想多了。“继承”正是针对这个目标而设计的。但继承并不完全等价于克隆。在继承过程中，若原始类（正式名称叫作基类、超类或父类）发生了变化，修改过的“克隆”类（正式名称叫作继承类或者子类）也会反映出这种变化。</p>
<p>创建基类以表示思想的核心。从基类中派生出其他类型来表示实现该核心的不同方式。</p>
<p><img src="/2020/04/08/%E3%80%8AOn-Java8%E3%80%8B1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/3.png" alt></p>
<p>有两种方法可以区分新的派生类与原始的基类。</p>
<ol>
<li>在派生类中添加新方法。</li>
<li>重写(Overriding)方法。</li>
</ol>
<h3 id="“是一个”与”像是一个”的关系"><a href="#“是一个”与”像是一个”的关系" class="headerlink" title="“是一个”与”像是一个”的关系"></a>“是一个”与”像是一个”的关系</h3><ol>
<li>继承只覆盖父类的方法，具有相同的接口。这样的话可以用一个子类完全替代父类，这种关系称为”是一个(is-a)“;</li>
<li>有时在子类中添加了新的方法，扩展了新的接口。此时子类不能完全替代父类，因为父类不能访问新添加的方法，这种关系称为”像是一个(is-like-a)“。</li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>通过继承，程序直到最后才能确定代码的地址。面向对象使用后期绑定的概念，当向对象发送信息时，被调用的代码直到运行时才确定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">    shape.erase();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">Triangle triangle = <span class="keyword">new</span> Triangle();</span><br><span class="line">Line line = <span class="keyword">new</span> Line();</span><br><span class="line">doSomething(circle);</span><br><span class="line">doSomething(triangle);</span><br><span class="line">doSomething(line);</span><br></pre></td></tr></table></figure>

<p>这种把子类当成其基类来处理的过程叫做“向上转型”（upcasting）。在面向对象的编程里，经常利用这种方法来给程序解耦。</p>
<p>发送消息给对象时，如果程序不知道接收的具体类型是什么，但最终执行是正确的，这就是对象的“多态性”（Polymorphism）。面向对象的程序设计语言是通过“动态绑定”的方式来实现对象的多态性的。</p>
<h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>Java 的单继承结构有很多好处。由于所有对象都具有一个公共接口，因此它们最终都属于同一个基类。</p>
<p>可以避免多继承中基类包含同名方法出错的问题。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>“集合”这种类型的对象可以存储任意类型、数量的其他对象。它能根据需要自动扩容，我们不用关心过程是如何实现的。</p>
<ol>
<li>集合可以提供不同类型的接口和外部行为。堆栈、队列的应用场景和集合、列表不同，它们中的一种提供的解决方案可能比其他灵活的多。</li>
<li>不同的集合某些操作有不同的效率。例如，List的两种基本类型：ArrayList和LinkedList。虽然两者具有相同的接口和外部行为，但是在某些<br>操作中它们的效率差别很大。在ArrayList中随机查找元素是很高效的，而LinkedList随机查找效率低下。反之，在LinkedList中插入元素的效率<br>要比在ArrayList中要高。由于底层数据结构的不同，每种集合类型在执行相同操作时会表现出效率上的差异。</li>
</ol>
<h2 id="对象创建和生命周期"><a href="#对象创建和生命周期" class="headerlink" title="对象创建和生命周期"></a>对象创建和生命周期</h2><p>Java使用动态内存分配。每次创建对象时，在堆内存中使用new关键字构建该对象的动态实例。在这种方式下，直到程序运行我们才能确定需要创建的<br>对象数量、生存时间和类型。什么时候需要，什么时候在堆内存中创建。因为内存的占用是动态管理的，所以在运行时，在堆内存开辟空间所需的时间<br>可能比在栈内存上要长(不一定)。在栈内存开辟和释放空间通常是一条将栈指针向下移动和一条将栈指针向上移动的汇编指令。开辟对内存空间的时间<br>取决于内存机制的设计。</p>
<p>Java的内存管理是建立在垃圾收集器上的，它能自动发现对象不再被使用并释放内存。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理机制将程序错误直接交给编程语言甚至是操作系统。”异常(Exception)“是一个从出错点”抛出”(thrown)后能被特定类型的异常处理程序捕<br>获(catch)的一个对象。他不会干扰程序的正常运行，仅当程序出错时才被执行。异常的发生是不会被忽略的，它终究会在某一时候被处理。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你看到的是对象的概念，这些概念是站在“问题空间”的(而不是站在计算机角度的“解决方案空间”)，以及发哦是那个消息给对象以指示该空间中的活动<br>。面向对象编程的一个优点是：设计良好的Java程序代码更容易被人阅读理解。由于Java类库的复用性，通常程序要写的代码也会少得多。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>On Java8读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收</title>
    <url>/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>垃圾回收是java针对堆中垃圾进行的清理，有效释放内存的一种手段。</p>
<h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h2><p>垃圾回收（Garbage Collection,GC)就是释放垃圾占用的空间，防止内存泄漏，可以有效使用内存，对内存堆中已经死亡或者长时间未使用的对象进行清除。</p>
<p>Java语言之前，C或者C++的程序创建对象需要不断开辟空间，当使用完成后需要释放，既要写构造函数，又要写析构函数，很多时候都在重复的 allocated，然后不停的析构。于是，有人就提出，能不能写一段程序实现这块功能，每次创建，释放控件的时候复用这段代码，而无需重复的书写呢？</p>
<p>1960年，基于 MIT 的 Lisp 首先提出了垃圾回收的概念，而这时 Java 还没有出世呢！所以实际上 GC 并不是Java的专利，GC 的历史远远大于 Java 的历史！</p>
<a id="more"></a>

<h2 id="怎么定义垃圾"><a href="#怎么定义垃圾" class="headerlink" title="怎么定义垃圾"></a>怎么定义垃圾</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用技术算法（Reachability Counting)是通过再对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用数加1，如果删除对该对象的引用，那么它的引用数就减1，当该对象的引用计数为0时，那么该对象就可以被回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String m = <span class="keyword">new</span> String(<span class="string">"jack"</span>);</span><br></pre></td></tr></table></figure>

<p>先创建一个字符串，这时候“jack”有一个引用，就是m。</p>
<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.png" alt></p>
<p>然后将m设置为null.这时候“jack”的引用次数就等于0了，在引用计数算法中，意味着这块内容就需要被回收了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.png" alt></p>
<p>引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了，而不是在进行垃圾搜集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束（不属于“Stop-The-World”）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountingGC</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ReferenceCountingGC a = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">"objA"</span>);</span><br><span class="line">    ReferenceCountingGC b = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">"objB"</span>);</span><br><span class="line"></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义两个对象</li>
<li>相互引用</li>
<li>置空各自的声明引用</li>
</ol>
<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.webp" alt></p>
<p>系统中不存在第三个对象引用a和b,所以a、b应该是系统回收的垃圾对象，但是因为垃圾对象之间的循环引用，引用计数器不为0，通过引用计数算法，也就永远无法通知GC收集器回收他们。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>可达性分析算法（Reachability Analysis）的基本思路是,通过一些被称为引用链(GC Roots)的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain）,当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。</p>
<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/4.jpg" alt></p>
<p>通过可达性算法，成功解决了引用计数无法解决的“循环依赖”问题，只要你无法与GC Root建立直接或间接的连接，系统就会判定你为可回收的对象。那这样就引申出了另一个问题，哪些属于 GC Root。</p>
<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>在java语言中，可作为GC Root的对象包括以下四种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/5.jpg" alt></p>
<h3 id="虚拟机栈（栈帧中的本地变量表）中引用的对象"><a href="#虚拟机栈（栈帧中的本地变量表）中引用的对象" class="headerlink" title="虚拟机栈（栈帧中的本地变量表）中引用的对象"></a>虚拟机栈（栈帧中的本地变量表）中引用的对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackLocalParameter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackLocalParameter</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StackLocalParameter s = <span class="keyword">new</span> StackLocalParameter(<span class="string">"localParameter"</span>);</span><br><span class="line">    s=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的s，即为GC Root,当s置空时，localParameter对象也断掉了与GC Root的引用链，将被回收。</p>
<h3 id="方法区中类静态属性引用的对象"><a href="#方法区中类静态属性引用的对象" class="headerlink" title="方法区中类静态属性引用的对象"></a>方法区中类静态属性引用的对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaStaicProperties</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodAreaStaicProperties m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAreaStaicProperties</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MethodAreaStaicProperties s = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"properties"</span>);</span><br><span class="line">    s.m = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"parameter"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>s为GC Root,s置为null,经过GC后，s所指的properties对象由于无法与GC Root建立关系被回收。<br>而m作为类的静态属性，也属于GC Root，parameter对象依然与GC Root建立着连接，所以此时parameter对象并不会被回收。</p>
<h3 id="方法区中常量引用的对象"><a href="#方法区中常量引用的对象" class="headerlink" title="方法区中常量引用的对象"></a>方法区中常量引用的对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">MethodAraaStaticProrperties</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodAraaStaticProrperties m = MethodAraaStaticProrperties(<span class="string">"final"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAraaStaticProrperties</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MethodAraaStaticProrperties s = <span class="keyword">new</span> MethodAraaStaticProrperties(<span class="string">"staticProperties"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m即为方法区中的常量引用，也为GC Root,s置为null后，final对象也不会因没有与GC Root建立联系而被回收。</p>
<h3 id="本地方法栈中引用的对象"><a href="#本地方法栈中引用的对象" class="headerlink" title="本地方法栈中引用的对象"></a>本地方法栈中引用的对象</h3><p>任何Native接口都会使用某种本地方法栈，实现的本地方法接口时使用C连接模型的话，那么它的本地方法栈就是C栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。<br>然而当它的调用是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的栈帧，虚拟机只是简单的连接并调用指定的本地方法。</p>
<p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/6.jpg" alt></p>
<h2 id="垃圾回收算法与思想"><a href="#垃圾回收算法与思想" class="headerlink" title="垃圾回收算法与思想"></a>垃圾回收算法与思想</h2><h3 id="标记–清除算法（Mark-Sweep"><a href="#标记–清除算法（Mark-Sweep" class="headerlink" title="标记–清除算法（Mark-Sweep)"></a>标记–清除算法（Mark-Sweep)</h3><p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/7.webp" alt></p>
<p>标记清除算法是现代垃圾回收算法的思想基础。它分为标记阶段和清除阶段。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在<br>清除阶段，清除所有未被标记的对象。</p>
<p>上图中等方块的假设是 2M，小一些的是 1M，大一些的是 4M。等我们回收完，内存就会切成了很多段。我们知道开辟内存空间时，需要的是连续的内存区域，这时候我们需要一个 2M的内存区域，<br>其中有2个 1M 是没法用的。这样就导致，其实我们本身还有这么多的内存的，但却用不了。</p>
<h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h3><p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/8.jpg" alt></p>
<p>将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p>
<p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此，在真正需要垃圾回收的时候，复制算法的效率是很高的。又由于对象是在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保<br>回收后的内存空间是没有碎片的。虽然有以上两大优点，但是复制算法的缺点是将系统内存折半，代价太大。</p>
<h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/9.webp" alt></p>
<p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也会<br>较高。因此，基于老年代垃圾回收的特性，需要使用新的算法。</p>
<p>标记整理算法标记过程仍然与标记–清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象移动到内存的一端。之后，清理掉边界外所有的空间。这种方法既避免了碎片的产生，又规避了复制算法<br>只能利用一半内存的弊端。但是它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。</p>
<p><em>分代收集算法（Generational Collection）</em></p>
<p>分代收集算法严格来说并不是一种思想或理论，而是融合上述三种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和来年代，这样<br>就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、<br>没有额外空间对它进行分配担保，就必须使用标记-清理或者标记-整理算法来回收。</p>
<h2 id="内存模型与回收策略"><a href="#内存模型与回收策略" class="headerlink" title="内存模型与回收策略"></a>内存模型与回收策略</h2><p><img src="/2020/04/01/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/10.webp" alt></p>
<p>Java堆(Java Heap)是JVM所管理的内存中最大的一块，堆有事垃圾收集器管理的主要区域。</p>
<p>Java堆主要分为两个区域-年轻代与老年代，其中年轻代又分为Eden区和Survivor区，其中Survivor区又分From和To两个区。</p>
<h3 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h3><p>IBM 公司的专业研究表明，有将近98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。</p>
<p>通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。</p>
<h3 id="Survivor-区"><a href="#Survivor-区" class="headerlink" title="Survivor 区"></a>Survivor 区</h3><p>Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。</p>
<p><strong>为啥需要？</strong></p>
<p>不就是新生代到老年代么，直接 Eden 到 Old 不好了吗，为啥要这么复杂。想想如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。</p>
<p>所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</p>
<p><strong>为啥需要俩？</strong></p>
<p>设置两个 Survivor 区最大的好处就是解决内存碎片化。</p>
<p>我们先假设一下，Survivor 如果只有一个区域会怎样。Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。</p>
<p>这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。</p>
<h3 id="Old-区"><a href="#Old-区" class="headerlink" title="Old 区"></a>Old 区</h3><p>老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记 — 整理算法。</p>
<p>除了上述所说，在内存担保机制下，无法安置的对象会直接进到老年代，以下几种情况也会进入老年代。</p>
<p><strong>大对象</strong></p>
<p>大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。</p>
<p><strong>长期存活对象</strong></p>
<p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加1岁。当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置。</p>
<p><strong>动态对象年龄</strong></p>
<p>虚拟机并不重视要求对象年龄必须到15岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。</p>
<p>这其实有点类似于负载均衡，轮询是负载均衡的一种，保证每台机器都分得同样的请求。看似很均衡，但每台机的硬件不通，健康状况不同，我们还可以基于每台机接受的请求数，或每台机的响应时间等，来调整我们的负载均衡算法。</p>
<p>说明：本文内容来自率鸽的博客和《Java程序性能优化》，非原创，供自我学习使用。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装mysql数据库</title>
    <url>/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="Windows10安装Docker"><a href="#Windows10安装Docker" class="headerlink" title="Windows10安装Docker"></a>Windows10安装Docker</h2><p>1.打开Docker官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-0.png" alt></p>
<a id="more"></a>

<p>2.点击Get started按钮进入主页面</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-1.png" alt="upload successful"><br>3.点击会跳转到Docker账号注册页面</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-2.png" alt="upload successful"><br>4.注册登录成功后跳转到下载页面</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-3.png" alt="upload successful"><br>5.开启win10的Hyper-V ， 控制面板 -&gt; 程序 -&gt; 启用或关闭Windows功能 -&gt; 选中Hyper-V  ，之后重启。 然后点击下载的exe安装文件安装，一路确定就好了。</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-4.png" alt="upload successful"><br>6.启动docker， setting -&gt; Daemon 设置阿里云docker镜像仓库。<br>到<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">https://cr.console.aliyun.com/</a> 注册一个账户，登录进去后再列表选择加速器，把你的专属加速器地址复制粘贴到Registry mirrors中<br><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-6.png" alt="upload successful"></p>
<h2 id="Docker安装Mysql-8-0"><a href="#Docker安装Mysql-8-0" class="headerlink" title="Docker安装Mysql 8.0"></a>Docker安装Mysql 8.0</h2><p>1.打开Windows PowerShell;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
<p>2.运行镜像，设置root账号初始密码（admin），映射本地宿主机端口3310到Docker端口3306;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run  --name mysql8.0 -e MYSQL_ROOT_PASSWORD&#x3D;admin -p 3310:3306 -d mysql</span><br></pre></td></tr></table></figure>
<p>3.查看运行中的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-7.png" alt="upload successful"><br>4.进入mysql容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql8.0 bash</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-8.png" alt="upload successful"><br>5.登录mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>6.允许外部连接数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER user &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;admin&#39;;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>7.查看用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select host,user,plugin,authentication_string from mysql.user;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-9.png" alt="upload successful"><br>host为 % 表示不限制ip   localhost表示本机使用    plugin非mysql_native_password 则需要修改密码</p>
<p>8.使用DataGrip进行连接；</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-10.png" alt="upload successful"></p>
<h2 id="Docker-push镜像"><a href="#Docker-push镜像" class="headerlink" title="Docker push镜像"></a>Docker push镜像</h2><p>接下来把我们的mysql镜像推送到自己的docker hub的存储库中去。</p>
<p>1.访问网址：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a> 在里面创建存储库</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-11.png" alt="upload successful"><br>2.把mysql镜像放入mysql存储库并标记为mysql8.0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag mysql creammangopie&#x2F;mysql:mysql8.0</span><br></pre></td></tr></table></figure>
<p>3.查看镜像</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-12.png" alt="upload successful"><br>4.推送镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker push creammangopie&#x2F;mysql:tagname</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-14.png" alt="upload successful"><br>5.Docker Hub上查看镜像</p>
<p><img src="/2020/01/08/Docker%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/pasted-15.png" alt="upload successful"><br>6.从远程存储库中提取并运行镜像：现在当远程存储库有了镜像后，就可以从远程存储库提取并运行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -e MYSQL_ROOT_PASSWORD&#x3D;admin -p 3310:3306 creammangopie&#x2F;mysql:mysql8.0</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>springBoot(一)：创建springBoot项目</title>
    <url>/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="springBoot是什么"><a href="#springBoot是什么" class="headerlink" title="springBoot是什么"></a>springBoot是什么</h2><p>Spring Boot是构建所有基于Spring的应用程序的起点。Spring Boot旨在通过最少的Spring前期配置使您尽快启动并运行。</p>
<p>Spring Boot使创建可运行的独立，生产级基于Spring的应用程序变得容易。我们对Spring平台和第三方库持固执己见的观点，这样您就可以以最小的麻烦开始使用。大多数Spring Boot应用程序只需要很少的Spring配置。</p>
<a id="more"></a>

<p>您可以使用Spring Boot创建可以通过使用java -jar或更传统的战争部署启动的Java应用程序。我们还提供了一个运行“ spring脚本”的命令行工具。</p>
<p>我们的主要目标是：</p>
<p>为所有Spring开发提供根本上更快且可广泛访问的入门体验。</p>
<p>开箱即用，但由于需求开始与默认值有所出入，因此很快就会摆脱困境。</p>
<p>提供一系列大型项目通用的非功能性功能（例如嵌入式服务器，安全性，指标，运行状况检查和外部化配置）。</p>
<p>完全没有代码生成，也不需要XML配置。<br>(来自于spring官方文档)</p>
<h2 id="从spring官网构建一个项目"><a href="#从spring官网构建一个项目" class="headerlink" title="从spring官网构建一个项目"></a>从spring官网构建一个项目</h2><p><strong>Maven构建项目</strong></p>
<ul>
<li>1、访问<a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a></li>
<li>2、选择构建工具 Maven Project、Java、Spring Boot 版本 2.2.3 ：<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/1.png" alt></li>
<li>3、点击 Generate Project 下载项目压缩包</li>
<li>4、解压后，使用 Idea 导入项目，import -&gt; 选择解压后的文件夹 -&gt; OK，选择 Maven 一路 Next，OK done!</li>
</ul>
<p><strong>Idea 构建项目</strong></p>
<ul>
<li>1、选择 File -&gt; New —&gt; Project… </li>
<li>2、选择 Spring Initializr，Next 也会出现上述类似的配置界面，Idea 帮我们做了集成</li>
<li>3、填写相关内容后，点击 Next 选择依赖的包再点击 Next，最后确定信息无误点击 Finish。</li>
</ul>
<p>创建完成后就是以下这样子了：<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/2.png" alt></p>
<ul>
<li>src/main/java 程序开发以及主程序入口</li>
<li>src/main/resources 配置文件</li>
<li>src/test/java 测试代码</li>
</ul>
<p><strong>引入web</strong></p>
<p>1、pom.xml中添加支持web的模块：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>pom.xml 文件中默认有两个模块：</p>
<ul>
<li>spring-boot-starter ：核心模块，包括自动配置支持、日志和 YAML，如果引入了 spring-boot-starter-web web 模块可以去掉此配置，因为 spring-boot-starter-web 自动依赖了 spring-boot-starter。</li>
<li>spring-boot-starter-test ：测试模块，包括 JUnit、Hamcrest、Mockito。</li>
</ul>
<p>2、写一个controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HellowWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加了@RestController就不需要再写@ResponseBody了。</p>
<p>3、启动主程序，打开浏览器访问 <a href="http://localhost:8080/hello，就可以看到效果了。" target="_blank" rel="noopener">http://localhost:8080/hello，就可以看到效果了。</a></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>打开的src/test/下的测试入口，编写简单的 http 请求来测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mvc = MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> HellowWorldController()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">"/hello"</span>).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(equalTo(<span class="string">"Hello World"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在springBoot2.2.3中@SpringBootTest注解集成了@ExtendWith({SpringExtension.class})，<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/3.png" alt></p>
<p>在Junit4中要加@RunWith(SpringRunner.class)。</p>
<ul>
<li>status()，content()，equalTo在代码中没有找到引用，手动引入的：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.equalTo;</span><br></pre></td></tr></table></figure>
运行test结果如下：<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/4.png" alt></li>
</ul>
<h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>Junit5升级之后很多注解发生变化。</p>
<table>
<thead>
<tr>
<th align="center">JUnit4</th>
<th align="center">JUnit5</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@Test</td>
<td align="center">@Test</td>
<td align="left">表示该方法是一个测试方法。JUnit5与JUnit 4的@Test注解不同的是，它没有声明任何属性，因为JUnit Jupiter中的测试扩展是基于它们自己的专用注解来完成的。这样的方法会被继承，除非它们被覆盖</td>
</tr>
<tr>
<td align="center">@BeforeClass</td>
<td align="center">@BeforeAll</td>
<td align="left">表示使用了该注解的方法应该在当前类中所有使用了@Test @RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行；</td>
</tr>
<tr>
<td align="center">@AfterClass</td>
<td align="center">@AfterAll</td>
<td align="left">表示使用了该注解的方法应该在当前类中所有使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后执行；</td>
</tr>
<tr>
<td align="center">@Before</td>
<td align="center">@BeforeEach</td>
<td align="left">表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之前 执行</td>
</tr>
<tr>
<td align="center">@After</td>
<td align="center">@AfterEach</td>
<td align="left">表示使用了该注解的方法应该在当前类中每一个使用了@Test、@RepeatedTest、@ParameterizedTest或者@TestFactory注解的方法之后 执行</td>
</tr>
<tr>
<td align="center">@Ignore</td>
<td align="center">@Disabled</td>
<td align="left">用于禁用一个测试类或测试方法</td>
</tr>
<tr>
<td align="center">@Category</td>
<td align="center">@Tag</td>
<td align="left">用于声明过滤测试的tags，该注解可以用在方法或类上；类似于TesgNG的测试组或JUnit 4的分类。</td>
</tr>
<tr>
<td align="center">@Parameters</td>
<td align="center">@ParameterizedTest</td>
<td align="left">表示该方法是一个参数化测试</td>
</tr>
<tr>
<td align="center">@RunWith</td>
<td align="center">@ExtendWith</td>
<td align="left">@Runwith就是放在测试类名之前，用来确定这个类怎么运行的</td>
</tr>
<tr>
<td align="center">@Rule</td>
<td align="center">@ExtendWith</td>
<td align="left">Rule是一组实现了TestRule接口的共享类，提供了验证、监视TestCase和外部资源管理等能力</td>
</tr>
<tr>
<td align="center">@ClassRule</td>
<td align="center">@ExtendWith</td>
<td align="left">@ClassRule用于测试类中的静态变量，必须是TestRule接口的实例，且访问修饰符必须为public。</td>
</tr>
</tbody></table>
<h2 id="添加项目热启动"><a href="#添加项目热启动" class="headerlink" title="添加项目热启动"></a>添加项目热启动</h2><p>1、pom.xml添加以下配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<p>2、yml配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">devtools:</span><br><span class="line">  livereload:</span><br><span class="line">    enabled: true #是否支持livereload</span><br><span class="line">    port: <span class="number">35729</span></span><br><span class="line">  restart:</span><br><span class="line">    enabled: true #是否支持热部署</span><br></pre></td></tr></table></figure>
<p>3、开启idea自动make功能<br>settings:<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/5.png" alt></p>
<p>4、ctrl + shift + alt + /,选择Registry,勾上 Compiler autoMake allow when app running<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/6.png" alt></p>
<p>5、安装livereload插件</p>
<p>livereload 通过引入的脚本livereload.js在 livereload 服务和浏览器之间建立了一个 WebSocket 连接。每当监测到文件的变动，livereload 服务就会向浏览器发送一个信号，浏览器收到信号后就刷新页面，实现了实时刷新的效果。每次启动时，需要点击对应的图标。<br>下载livereload插件，将其安装到chrome扩展程序中。<br><img src="/2019/12/30/springBoot(%E4%B8%80)%EF%BC%9A%E5%88%9B%E5%BB%BAspringBoot%E9%A1%B9%E7%9B%AE/7.png" alt></p>
<p>6、测试</p>
<ul>
<li>修改类 应用会重启</li>
<li>修改配置文件 应用会重启</li>
<li>修改静态文件（html、css等），应用不会重启，但是会调用livereload，浏览器会自动刷新，显示最新的修改内容。</li>
</ul>
]]></content>
      <categories>
        <category>springBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>热部署</tag>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的事务管理</title>
    <url>/2019/12/27/Mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h1><p>事务是逻辑上的一组操作，要求这一组操作要么同时完成 要么同时不完成。</p>
<h1 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h1><p>数据库默认就有事务，mysql中默认情况下一条语句独占一个事务。<br>也可以通过手动控制事务：</p>
<a id="more"></a>
<h2 id="sql控制事务："><a href="#sql控制事务：" class="headerlink" title="sql控制事务："></a>sql控制事务：</h2><p>start transaction; #开启一个事务 这条语句之后的所有的sql都将处在同一个事务中。这些sql都不会立即起作用 - 没有改变底层真正的数据。</p>
<p>commit; #提交事务 这个事务中所有的sql对数据库的影响立即发生 - 真正改变底层数据。</p>
<p>rollback; #回滚事务 撤销这个事务中所有的操作可能的对数据库的影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update account <span class="keyword">set</span> money = money-100 where name='a';</span><br><span class="line">update account <span class="keyword">set</span> money = money+100 where name='b';</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">start transaction;</span><br><span class="line">update account <span class="keyword">set</span> money = money-100 where name='a';</span><br><span class="line">update account <span class="keyword">set</span> money = money+100 where name='b';</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>
<h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">conn.setAutoCommit(false);#开启了事务，接下来在这个连接执行的所有sql都将处在同一个事务当中。</span><br><span class="line">			....</span><br><span class="line">conn.commit();#提交事务，将这个连接上执行的事务提交，对数据库产生影响。</span><br><span class="line">conn.rollback();#回滚事务，取消这个连接上执行的事务。</span><br><span class="line"></span><br><span class="line">SavePoint sp = conn.setSavePoint();</span><br><span class="line">conn.rollback(sp);</span><br></pre></td></tr></table></figure>
<p>要注意，回滚到回滚点时，回滚点之前的代码仍然是未提交也未回滚的状态，如果希望对数据库产生影响仍然需要进行提交的操作。</p>
<h1 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性  - ACID"></a>事务的四大特性  - ACID</h1><p>原子性 - 事务中的一组操作是不可分割的一个整体，要么一起成功，要么一起失败。</p>
<p>一致性 - 事务前后 无论事务是否成功 数据库应该都保持一个完整性的状态。数据库中数据是业务完整且约束完整的。</p>
<p>隔离性 - 多个并发事务之间应该互相隔离 互不影响</p>
<p>持久性 - 一个事务成功对数据库产生的影响是永久性的，无论发生什么情况 这种影响都不会被取消。</p>
<h1 id="隔离性的问题"><a href="#隔离性的问题" class="headerlink" title="隔离性的问题"></a>隔离性的问题</h1><p>加锁：同一时间内只能有一个人操作数据，可以完美的保证隔离性，但是这样一来数据库就相当于工作在单线程的状态下，同一时间只能有一个事务操作，并发的效率非常低下。</p>
<p>而现实生活中并不是所有的场景下都需要那么严格的事务隔离，在不同的业务场景下对隔离性的要求是不同的。</p>
<p>所以数据库的设计者在设计隔离性时并没有将隔离性写死，而是提供了不同的选项，数据库的使用者可以在使用数据时根据自身需求选择对应的选项来得到相应的隔离能力和性能。</p>
<p>通过这些选项，数据库使用者可以在数据库的隔离能力和性能间做一个权衡，从而在保证需要的隔离性的基础上得到尽量好的性能。</p>
<h1 id="四大隔离级别"><a href="#四大隔离级别" class="headerlink" title="四大隔离级别"></a>四大隔离级别</h1><p>Read uncommitted<br>Read committed<br>Repeatable read<br>Serializable  </p>
<p>(1)Read uncoommitted<br>    数据库不保证任何事务特性 可能出现脏读 不可重复读 虚读(幻读) 问题<br>    <strong>脏读</strong>:一个事务读取到了另一个事务未提交的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">	<span class="keyword">set</span> session transaction isolation level read uncoommitted;</span><br><span class="line">---------------</span><br><span class="line">	a: 1000</span><br><span class="line">	b: 1000</span><br><span class="line">---------------</span><br><span class="line">b:</span><br><span class="line">	start transaction;</span><br><span class="line">	update account <span class="keyword">set</span> money = money - 100 where name = 'b';</span><br><span class="line">	update account <span class="keyword">set</span> money = money + 100 where name = 'a';</span><br><span class="line"></span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	select * from account;</span><br><span class="line">---------------</span><br><span class="line">	a: 1100</span><br><span class="line">	b: 900</span><br><span class="line">---------------</span><br><span class="line">	commit;</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">	rollback;</span><br><span class="line"></span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	select * from account;</span><br><span class="line">---------------</span><br><span class="line">	a: 1000</span><br><span class="line">	b: 1000</span><br><span class="line">---------------</span><br><span class="line">	commit;</span><br></pre></td></tr></table></figure>
<p>(2)Read committed<br>保证部分隔离 可以防止脏读问题 但是具有不可重复读 和 虚读(幻读)问题<br><strong>不可重复读</strong>：一个事务读取到另一个事务已经提交的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a:</span><br><span class="line">	<span class="keyword">set</span> session transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 1000 1000</span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">	start transaction;</span><br><span class="line">	select 活期 from account where name = 'a'; -- 活期存款1000</span><br><span class="line">	select 定期 from account where name = 'a'; -- 定期存款1000</span><br><span class="line">	select 固定 from account where name = 'a'; -- 固定存款1000</span><br><span class="line">-------------------------</span><br><span class="line">a:</span><br><span class="line">	start transaction;</span><br><span class="line">	update account <span class="keyword">set</span> money = money - 1000 where name = 'a';</span><br><span class="line">	commit;</span><br><span class="line">-------------------------</span><br><span class="line">b:</span><br><span class="line">    select 活期 + 定期 + 固定 from account where name = 'a';</span><br><span class="line">-------------------------</span><br><span class="line">    总资产2000</span><br></pre></td></tr></table></figure>

<p>(3)Repeatable read<br>保证部分隔离 可以防止脏读 不可重复读问题 但是具有虚读(幻读)问题<br><strong>虚读(幻读)</strong>：一个事务读取全表数据时 读取到另一个事务向表中新增、删除操作提交的结果<br>**虚读(幻读)问题 有可能出现 有可能不出现 概率非常低</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation level Repeatable read;</span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 </span><br><span class="line">	b 1000</span><br><span class="line">-------------------------</span><br><span class="line">c：</span><br><span class="line">	start transaction;</span><br><span class="line">	select count(*) from account; -- 2人</span><br><span class="line">	select sum(money) from account; -- 2000元</span><br><span class="line">--------</span><br><span class="line">d：</span><br><span class="line">	start transaction;</span><br><span class="line">	insert into account values(d 4000);</span><br><span class="line">	commit;</span><br><span class="line">-------------------------</span><br><span class="line">	a 1000 </span><br><span class="line">	b 1000</span><br><span class="line">	d 4000</span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line">select avg(money) from account; -- 2000元</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>(4)Serializable<br>保证完全隔离 可以防止脏读 不可重复读 虚读(幻读)问题<br>本质上是靠锁来实现的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">从安全性说：</span><br><span class="line">	Serializable &gt; Repeatable read &gt; Read committed &gt; Read uncommitted </span><br><span class="line">从效率说：</span><br><span class="line">	Read uncommitted &gt;Read committed &gt; Repeatable read &gt; Serializable</span><br></pre></td></tr></table></figure>
<p>真正在开发的过程中应该根据自身的业务需求选择一个在<strong>能防止想要防止的隔离性问题的级别</strong>中<strong>性能</strong>最好的一个隔离级别<br>mysql的<strong>默认</strong>隔离级别时 <strong>Repeatable read</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">查看数据库隔离级别：</span><br><span class="line">	select @@tx_isolation;</span><br><span class="line">设置数据库的隔离级别:</span><br><span class="line">	<span class="keyword">set</span> [session/global] transaction isolation level xxxxxx;</span><br></pre></td></tr></table></figure>

<h1 id="数据库中的锁机制"><a href="#数据库中的锁机制" class="headerlink" title="数据库中的锁机制"></a>数据库中的锁机制</h1><p>数据库中是有锁的，但是锁如果控制不好，对效率影响非常大，所以数据库设计者对锁做了特别的设计：  </p>
<table>
<thead>
<tr>
<th align="center">业务情况</th>
<th align="center">是否互斥</th>
</tr>
</thead>
<tbody><tr>
<td align="center">两个查询</td>
<td align="center">没有必要互斥</td>
</tr>
<tr>
<td align="center">两个修改</td>
<td align="center">必须互斥</td>
</tr>
<tr>
<td align="center">一个查询 另一个修改</td>
<td align="center">具体看情况 Serializable隔离级别下需要排斥 其他隔离级别不需要</td>
</tr>
</tbody></table>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁和共享锁可以共存，共享锁和排他锁不能共存<br>在非Serializable级别中查询不加任何锁 在Seralizable级别中查询加共享锁</p>
<h2 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h2><p> 排他锁和任何锁都不能共存<br> 在任意隔离级别下做增删改都加排他锁</p>
<p><strong>操作和锁的关系</strong><br>            1. 非Serializable级别,查询不加任何锁<br>            2. Serializable级别,查询加共享锁<br>            3. 任意隔离级别下,增删改都加排他锁</p>
<table>
<thead>
<tr>
<th>a(Rep)</th>
<th>b(Rep)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>都不加锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>不互斥</td>
<td>a不加锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>不互斥</td>
<td>a排他锁+b不加锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a(Ser)</th>
<th>b(Rep)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>a共享锁+b不加锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>互斥</td>
<td>a共享锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>不互斥</td>
<td>a排他锁+b不加锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>a(Ser)</th>
<th>b(Ser)</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>a查询</td>
<td>b查询</td>
<td>不互斥</td>
<td>a共享锁+b共享锁</td>
</tr>
<tr>
<td>a查询</td>
<td>b增删改</td>
<td>互斥</td>
<td>a共享锁+b排他锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b查询</td>
<td>互斥</td>
<td>a排他锁+b共享锁</td>
</tr>
<tr>
<td>a增删改</td>
<td>b增删改</td>
<td>互斥</td>
<td>a排他锁+b排他锁</td>
</tr>
</tbody></table>
<p>死锁：<br>    当两边都时Serializable隔离级别时<br>    两边都先进行查询 再尝试进行修改 则互相等待对方释放共享锁 都无法接着执行 造成了死锁<br>死锁的解决有两种办法：避免死锁 解决死锁<br>    mysql没有避免死锁，尝试检测死锁，发现死锁后，退出一方，执行另一方来解决了死锁。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>default关键字</title>
    <url>/2019/12/27/default%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>default关键字在Java中主要有两个用法，一个是在switch中执行，另一个是jdk1.8之后使用default关键字在接口中定义普通方法。</p>
<h1 id="default在Switch中的使用"><a href="#default在Switch中的使用" class="headerlink" title="default在Switch中的使用"></a>default在Switch中的使用</h1><p>default会在case匹配失败后执行</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ch = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是0"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是1"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">              System.out.println(<span class="string">"内容是2"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              System.out.println(<span class="string">"默认值"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：<code>default</code><br>注：若case中没有break，则匹配成功后会继续执行代码，直到碰到break或return或者switch语句结束为止，这种情况下default可能会执行。</p>
<h1 id="default在接口中的使用（jdk1-8之后）"><a href="#default在接口中的使用（jdk1-8之后）" class="headerlink" title="default在接口中的使用（jdk1.8之后）"></a>default在接口中的使用（jdk1.8之后）</h1><p>在jdk1.8之后，接口中可以使用default定义普通方法。这样如果某些方法对于所有的子类都具有同样的实现，那么可以减少定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        是一个普通方法，jdk1.8之后才有</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">"我是接口1的普通方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMss</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是接口1的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        IMessage1 iMessage = <span class="keyword">new</span> MessageImpl1();</span><br><span class="line">        iMessage.print();</span><br><span class="line">        iMessage.getMsg();</span><br><span class="line">        IMessage1.getMss();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><code>MessageImpl1
我是接口1的普通方法
我是接口1的静态方法</code></p>
<h2 id="两个接口中默认方法冲突问题"><a href="#两个接口中默认方法冲突问题" class="headerlink" title="两个接口中默认方法冲突问题"></a>两个接口中默认方法冲突问题</h2><p>当一个类实现了两个接口，而两个接口中都有相同的默认方法，此时会出现什么情况呢？<br>我们再来定义一个新的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是接口2的普通方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让一个类同时实现接口1和接口2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl</span> <span class="keyword">implements</span> <span class="title">IMessage1</span> , <span class="title">IMessage2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时编译器会报错<br><img src="https://img-blog.csdnimg.cn/20190804143036881.png" alt="IDEA中方法冲突提示"><br>此时编译器不知道应该从哪个接口中去调用默认方法，所以报错。<br>解决方法：<code>在实现类中重写该方法</code></p>
<h2 id="类与接口中定义了相同的方法"><a href="#类与接口中定义了相同的方法" class="headerlink" title="类与接口中定义了相同的方法"></a>类与接口中定义了相同的方法</h2><p>实现类1实现接口1并重写getMsg()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm from MessageImpl1 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类2继承实现类1并实现接口2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageImpl2</span> <span class="keyword">extends</span> <span class="title">MessageImpl1</span> <span class="keyword">implements</span> <span class="title">IMessage2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若此时在实现类2中调用getMsg()方法，是执行MessageImpl1中的方法还是IMessage2中的呢？<br>执行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MessageImpl2 messageImpl2 = <span class="keyword">new</span> MessageImpl2();</span><br><span class="line">        messageImpl2.getMsg();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<code>I&#39;m from MessageImpl1</code><br>答：<strong>类优先级高于接口</strong>，所以执行实现类1中的方法。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>-java语法</tag>
      </tags>
  </entry>
</search>
